---
title: "What controls the range of hosts a fish parasite infects?"
author: "Tad Dallas, Andrew Park, and John M. Drake"
output:
  html_document:
    fig_height: 6
    fig_width: 6
    highlight: tango
    theme: journal
  pdf_document: default
bibliography: carp.bib
---


```{r echo=FALSE, message=FALSE, comment=FALSE}
## Load in some data and required packages
library(rfishbase); library(gbm); library(ROCR); library(e1071); library(randomForest)
load('/media/drakelab/Lexar/8910Project/Analysis/RdataFiles/pest(reduced).RData')
load('/media/drakelab/Lexar/8910Project/Analysis/RdataFiles/pest(reduced)2_2.RData')
```


### Knowledge gap

* What constrains the range of hosts that a parasite can infect? Is there a simple range of host functional traits that can determine the likelihood that a parasite infects a given host species? How well can we predict parasite occurrences given host life history traits? How about using solely information on parasite community structure? 

* Does the importance of different host functional traits or parasite community information differ with parasite type? (supplement)

* Since geographic variables are important, what if we try to predict parasite niche breadth in a specific biogeographic region? (supplement)



### Thesis paragraph

Here, I apply a series of predictive models in order to predict parasite occurrence across a range of potential host species for a large set of parasites of freshwater fish, using host functional traits, geographic location, and parasite community information. Parasite occurrence on a given host could be constrained by space (geographic location), patch quality (host characteristics), or through interactions with competing parasites (parasite community structure). It's important to note right up front that the importance of parasite community structure cannot be interpreted as evidence for community interactions, as parasites could infect hosts based on their traits, and the parasite community information could just be serving as a proxy for unmeasured host trait variation. However, predicting parasite occurrence based solely on parasite community information does remove some importance of the patch (host), and is easy to sell, as it may be possible to predict spillover of parasites, or the degree of biotic resistance a community offers to a potential invader, simply by having presence-absence data on parasite communities. 


I examine the role of parasite group (Acanthocephala, Cestoda, Monogenea, Nematoda, Trematoda) on model performance, and on the relative contribution of different variables to prediction. 







## Methods

### Data and processing
 We use an existing global database of fish-parasite associations [@strona2013] consisting of over 38000 parasite records spanning a large diversity of parasites (Acanthocephala, Cestoda, Monogenea, Nematoda, Trematoda). In order to allow for cross-validation and accurate prediction, we constrained our ananlyses to parasites with a minimum of 50 host records. In other words, we only examined parasites that had been recorded more than 50 times, but these occurrences could be on fewer than 50 host species. The inclusion of duplicate occurrences was only permitted if the parasite was recorded on a host in a different location, based on latitude and longitude values. Our response variable was parasite occurrence (binary), and was predicted using only host life history traits, and geographic location of host capture. Host trait information was obtained through the FishPest database [@strona2012; @strona2013], and FishBase [@froese2010]. Host traits descriptions are provided in Table 1
 
 
### Model formulation 
  We trained a series of models in order to compare predictive performance of different techniques. Each model was trained on 70% of the data, and accuracy was determined from the remaining 30%. This process was repeated $z$ times ($z$ = 20). We generated background data by randomly sampling host species where parasite $i$ was not recorded. To maintain proportional training data, the number of random samples was selected to be five times greater than the occurrence records. 
  
### Models used
 discuss null predictions scenario, and then go into other algorithms used (brt, svm, lr, rf)





#### Training using only host trait data 

```{r, eval=FALSE, echo=F, message=FALSE}
# storage for model outputs
baseline.auc=vector(); aso.auc=vector()
brtModel=list(); brt.best.iter=list(); brt.preds=list(); brt.perf=list(); brt.perfAUC=vector()
svmModel=list(); svm.preds=list(); svm.perf=list(); svm.perfAUC=vector()
lrModel=list(); lr.preds=list(); lr.perf=list(); lr.perfAUC=vector()
rfModel=list(); rf.preds=list(); rf.perf=list(); rf.perfAUC=vector()


## Creating a pointsObject
#hostPest = unique(pest[,-c(1:3)], MARGIN=1)
hostPest = pest[,c(4:8, 10:14)]
parPest = names(which(summary(pest1[,'P_SP'], maxsum=500)>20)); 
parPest=parPest[-max(length(parPest))]

ret=list()
for(i in 1:length(parPest)){
#create presence vector
  presence=rep(0, nrow(hostPest))
  presence[which(hostPest[,'P_SP'] == parPest[i])]=1

#make some 'na' into actual NAs
  ugh=which(hostPest=='na', arr.ind=TRUE)
  hostPest[ugh]=NA
  hostPest[,6:10]=apply(hostPest[,6:10],2, as.numeric)


#Only train on some of the absences, since they're totally not true absences
  cutDown=c(which(presence==1), sample(which(presence==0), 5*sum(presence)))
  presence1=presence[cutDown]
  dat=hostPest[cutDown, -c(1:4)]
  hostsOfi=dat[,1]
  
#Impute the data
  impDat=rfImpute(dat[,-1], presence1)
  dat=impDat[,-1]


  # This makes sure that the test set contains at least 4 hosts on which the parasite actually occurs
  inds=sample(1:nrow(dat), 0.7*nrow(dat))
  if(sum(presence1[inds]) < 4){inds[1:4] = which(presence1 == 1)[1:4]}

  #Set up a prelim train set and a test set
  train = dat[inds,]
  test = dat[-inds,]  
 
 #Presences
  prezTR=presence1[inds]
  prezTE=presence1[-inds]

#baseline expectations and null models
  baseline.auc[i] = performance(prediction(sample(presence[-inds], length(presence[-inds])), presence[-inds]), 'auc')@y.values
   
  # A single occurrence prediction
  aso.auc[i]= unlist(performance(prediction(c(1,rep(0, length(prezTE)-1)), prezTE), 'auc')@y.values)

 ##trained models
  #boosted regression trees
    brtModel[[i]] = gbm(prezTR ~ ., data=train, n.trees=50000, interaction.depth=4, distribution='bernoulli')
    brt.best.iter[[i]] = gbm.perf(brtModel[[i]], method="OOB")
    brt.preds[[i]] = prediction(predict(brtModel[[i]], newdata=test, n.trees=brt.best.iter[[i]]), prezTE)
    brt.perf[[i]] = performance(brt.preds[[i]],"tpr","fpr")
    brt.perfAUC[i]=unlist(performance(brt.preds[[i]], 'auc')@y.values)

  #support vector machines
    svmModel[[i]] = svm(prezTR ~ ., data=train, probability=TRUE, kernal='radial')
    svm.preds[[i]] = prediction(predict(svmModel[[i]], test), prezTE)
    svm.perf[[i]] = performance(svm.preds[[i]],"tpr","fpr")
    svm.perfAUC[i] = unlist(performance(svm.preds[[i]], 'auc')@y.values)

  #logistic regression
    lrModel[[i]] = glm(prezTR ~ ., data=train, family=binomial)
    lr.preds[[i]] = prediction(predict(lrModel[[i]], test), prezTE)
    lr.perf[[i]] = performance(lr.preds[[i]],"tpr","fpr")
    lr.perfAUC[i] = unlist(performance(lr.preds[[i]], 'auc')@y.values)

  #random forest
    rfModel[[i]] = randomForest(prezTR ~ ., data=train)
    rf.preds[[i]] = prediction(predict(rfModel[[i]], test), prezTE)
    rf.perf[[i]] = performance(rf.preds[[i]],"tpr","fpr")
    rf.perfAUC[i] = unlist(performance(rf.preds[[i]], 'auc')@y.values)
  print(i)
  }

 ret=cbind(baseline.auc, aso.auc, brt.perfAUC, svm.perfAUC, lr.perfAUC, rf.perfAUC)
 colnames(ret)=c('BASE', 'Zero', 'BRT', 'SVM', 'LR', 'RF')
```





#### Training using only geographic

```{r, eval=FALSE, echo=F, message=FALSE}
# storage for model outputs
baseline.auc.geo=vector(); aso.auc.geo=vector()
brtModel.geo=list(); brt.best.iter.geo=list(); brt.preds.geo=list(); brt.perf.geo=list(); brt.perfAUC.geo=vector(); 
svmModel.geo=list(); svm.preds.geo=list(); svm.perf.geo=list(); svm.perfAUC.geo=vector()
lrModel.geo=list(); lr.preds.geo=list(); lr.perf.geo=list(); lr.perfAUC.geo=vector()
rfModel.geo=list(); rf.preds.geo=list(); rf.perf.geo=list(); rf.perfAUC.geo=vector()


## Creating a pointsObject
#hostPest = unique(pest[,-c(1:3)], MARGIN=1)
hostPest = pest[,c(4:9, 18:20)]
parPest = names(which(summary(pest[,'P_SP'], maxsum=500)>19)); 
parPest=parPest[-max(length(parPest))]


for(i in 226:length(parPest)){
#create presence vector
  presence=rep(0, nrow(hostPest))
  presence[which(hostPest[,'P_SP'] == parPest[i])]=1

#make some 'na' into actual NAs
  ugh=which(hostPest=='na', arr.ind=TRUE)
  hostPest[ugh]=NA
  hostPest[,7:9]=apply(hostPest[,7:9],2, as.numeric)


#Only train on some of the absences, since they're totally not true absences
  cutDown=c(which(presence==1), sample(which(presence==0), 5*sum(presence)))
  presence1=presence[cutDown]
  dat=hostPest[cutDown, -c(1:4)]
  hostsOfi=dat[,1]
  
#Impute the data
  impDat=rfImpute(dat[,-1], presence1)
  dat=impDat[,-1]

flag=0
 while(flag == 0){
  # This makes sure that the test set contains at least 4 hosts on which the parasite actually occurs
  inds=sample(1:nrow(dat), 0.7*nrow(dat))
  if(sum(presence1[inds]) < 4){inds[1:4] = which(presence1 == 1)[1:4]}

  #Set up a prelim train set and a test set
  train = dat[inds,]
  test = dat[-inds,]  
  if(all(unique(train$GEO) %in% unique(test$GEO))){flag=1}
 }
 
 #Presences
  prezTR=presence1[inds]
  prezTE=presence1[-inds]

  
  #baseline expectations and null models
  baseline.auc.geo[i] = performance(prediction(sample(presence[-inds], length(presence[-inds])), presence[-inds]), 'auc')@y.values
   
  # A single occurrence prediction
  aso.auc.geo[i]= unlist(performance(prediction(c(1,rep(0, length(prezTE)-1)), prezTE), 'auc')@y.values)

 ##trained models
  #boosted regression trees
    brtModel.geo[[i]] = gbm(prezTR ~ ., data=train, n.trees=50000, interaction.depth=4, distribution='bernoulli')
    brt.best.iter.geo[[i]] = gbm.perf(brtModel.geo[[i]], method="OOB")
    brt.preds.geo[[i]] = prediction(predict(brtModel.geo[[i]], newdata=test, n.trees=brt.best.iter.geo[[i]]), prezTE)
    brt.perf.geo[[i]] = performance(brt.preds.geo[[i]],"tpr","fpr")
    brt.perfAUC.geo[i]=unlist(performance(brt.preds.geo[[i]], 'auc')@y.values)

  #support vector machines
    svmModel.geo[[i]] = svm(prezTR ~ ., data=train, probability=TRUE, kernal='radial')
    svm.preds.geo[[i]] = prediction(predict(svmModel.geo[[i]], test), prezTE)
    svm.perf.geo[[i]] = performance(svm.preds.geo[[i]],"tpr","fpr")
    svm.perfAUC.geo[i] = unlist(performance(svm.preds.geo[[i]], 'auc')@y.values)

  #logistic regression
    lrModel.geo[[i]] = glm(prezTR ~ ., data=train, family=binomial)
    lr.preds.geo[[i]] = prediction(predict(lrModel.geo[[i]], test), prezTE)
    lr.perf.geo[[i]] = performance(lr.preds.geo[[i]],"tpr","fpr")
    lr.perfAUC.geo[i] = unlist(performance(lr.preds.geo[[i]], 'auc')@y.values)

  #random forest
    rfModel.geo[[i]] = randomForest(prezTR ~ ., data=train)
    rf.preds.geo[[i]] = prediction(predict(rfModel.geo[[i]], test), prezTE)
    rf.perf.geo[[i]] = performance(rf.preds.geo[[i]],"tpr","fpr")
    rf.perfAUC.geo[i] = unlist(performance(rf.preds.geo[[i]], 'auc')@y.values)
  print(i)
  }

 ret.geo=cbind(baseline.auc.geo, aso.auc.geo, brt.perfAUC.geo, svm.perfAUC.geo, lr.perfAUC.geo, rf.perfAUC.geo)
 colnames(ret.geo)=c('BASE', 'Zero', 'BRT', 'SVM', 'LR', 'RF')
```









#### Training using only parasite community data

```{r, eval=FALSE, echo=F, message=FALSE}
# storage for model outputs
baseline.auc.b=vector(); 
aso.auc.b=vector() ;
brtModel.b=list(); brt.best.iter.b=list(); brt.preds.b=list(); brt.perf.b=list(); brt.perfAUC.b=vector()
svmModel.b=list(); svm.preds.b=list(); svm.perf.b=list(); svm.perfAUC.b=vector()
lrModel.b=list(); lr.preds.b=list(); lr.perf.b=list(); lr.perfAUC.b=vector()
rfModel.b=list(); rf.preds.b=list(); rf.perf.b=list(); rf.perfAUC.b=vector()


## Creating a pointsObject
#hostPest = unique(pest[,-c(1:3)], MARGIN=1)
hostPest = pest[,-c(1:3)]
parPest = names(which(summary(pest[,'P_SP'], maxsum=500)>19)); 
parPest=parPest[-max(length(parPest))]

for(i in 1:length(parPest)){
 #create presence vector
  presence=rep(0, nrow(hostPest))
  presence[which(hostPest[,'P_SP'] == parPest[i])]=1

#make some 'na' into actual NAs
  ugh=which(hostPest=='na', arr.ind=TRUE)
  hostPest[ugh]=NA
  hostPest[,7:17]=apply(hostPest[,7:17],2, as.numeric)


#Only train on some of the absences, since they're totally not true absences
  cutDown=c(which(presence==1), sample(which(presence==0), 5*sum(presence)))
  presence1=presence[cutDown]
  dat=hostPest[cutDown, -c(1:4)]
  hostsOfi=dat[,1]
  
#Impute the data
 # impDat=rfImpute(dat[,-1], presence1)
 # dat=impDat[,-1]


###### If you want to include parasite richness (or composition) ######
 psr = rowSums(intMat > 0)
#PCA of parasite communities...otherwise you're including like 500 new variables
pcaHosts = princomp(intMat[,-which(colnames(intMat)==parPest[i])])$scores

#
#pcaUGH=vector()
#for(i in 1:length(parPest)){
#  a=princomp(intMat[,-which(colnames(intMat)==parPest[i])])
#  pcaUGH[i]=as.vector(cumsum(a$sdev^2)/sum(a$sdev^2))[5]
#}
#


psrOut=vector()
pcaHostsOut=matrix(0, nrow=length(hostsOfi), ncol=5)
for(e in 1:length(hostsOfi)){
  psrOut[e] = psr[which(hostsOfi[e] == rownames(intMat))]
  pcaHostsOut[e,] = pcaHosts[which(hostsOfi[e] == rownames(intMat)), 1:5]
}

dat = data.frame(psrOut, pcaHostsOut)

  # This makes sure that the test set contains at least 4 hosts on which the parasite actually occurs
  inds=sample(1:nrow(dat), 0.7*nrow(dat))
  if(sum(presence1[inds]) < 4){inds[1:4] = which(presence1 == 1)[1:4]}

  #Set up a prelim train set and a test set
  train = dat[inds,]
  test = dat[-inds,]  
 
 
 #Presences
  prezTR=presence1[inds]
  prezTE=presence1[-inds]
  
  #baseline expectations and null models
  baseline.auc.b[i] = performance(prediction(sample(presence[-inds], length(presence[-inds])), presence[-inds]), 'auc')@y.values
 
# A single occurrence prediction
  aso.auc.b[i]= performance(prediction(c(1,rep(0, length(prezTE)-1)), prezTE), 'auc')@y.values

 ##trained models
  #boosted regression trees
    brtModel.b[[i]] = gbm(prezTR ~ ., data=train, n.trees=50000, interaction.depth=4, distribution='bernoulli')
    brt.best.iter.b[[i]] = gbm.perf(brtModel.b[[i]], method="OOB")
    brt.preds.b[[i]] = prediction(predict(brtModel.b[[i]], newdata=test, n.trees=brt.best.iter.b[[i]]), prezTE)
    brt.perf.b[[i]] = performance(brt.preds.b[[i]],"tpr","fpr")
    brt.perfAUC.b[i]=unlist(performance(brt.preds.b[[i]], 'auc')@y.values)

  #support vector machines
    svmModel.b[[i]] = svm(prezTR ~ ., data=train, probability=TRUE)
    svm.preds.b[[i]] = prediction(predict(svmModel.b[[i]], test), prezTE)
    svm.perf.b[[i]] = performance(svm.preds.b[[i]],"tpr","fpr")
    svm.perfAUC.b[i] = unlist(performance(svm.preds.b[[i]], 'auc')@y.values)

  #logistic regression
    lrModel.b[[i]] = glm(prezTR ~ ., data=train, family=binomial)
    lr.preds.b[[i]] = prediction(predict(lrModel.b[[i]], test), prezTE)
    lr.perf.b[[i]] = performance(lr.preds.b[[i]],"tpr","fpr")
    lr.perfAUC.b[i] = unlist(performance(lr.preds.b[[i]], 'auc')@y.values)

  #random forest
    rfModel.b[[i]] = randomForest(prezTR ~ ., data=train)
    rf.preds.b[[i]] = prediction(predict(rfModel.b[[i]], test), prezTE)
    rf.perf.b[[i]] = performance(rf.preds.b[[i]],"tpr","fpr")
    rf.perfAUC.b[i] = unlist(performance(rf.preds.b[[i]], 'auc')@y.values)
  print(i)
  }

 ret.b=cbind(baseline.auc.b, aso.auc.b, brt.perfAUC.b, svm.perfAUC.b, lr.perfAUC.b, rf.perfAUC.b)
 colnames(ret.b)=c('BASE','Zero', 'BRT', 'SVM', 'LR', 'RF')
```




#### Training using all data

*** Run this model again ***

```{r, eval=FALSE, echo=F, message=FALSE}
# storage for model outputs
baseline.auc.c=vector();
aso.auc.c=vector()
brtModel.c=list(); brt.best.iter.c=list(); brt.preds.c=list(); brt.perf.c=list(); brt.perfAUC.c=vector()
svmModel.c=list(); svm.preds.c=list(); svm.perf.c=list(); svm.perfAUC.c=vector()
lrModel.c=list(); lr.preds.c=list(); lr.perf.c=list(); lr.perfAUC.c=vector()
rfModel.c=list(); rf.preds.c=list(); rf.perf.c=list(); rf.perfAUC.c=vector()


## Creating a pointsObject
#hostPest = unique(pest[,-c(1:3)], MARGIN=1)
hostPest = pest[,c(4:14, 18:20)]
hostPest[,7:14]=apply(hostPest[,7:14],2, as.numeric)
parPest = names(which(summary(pest1[,'P_SP'], maxsum=500)>20)); 
parPest=parPest[-max(length(parPest))]


for(i in 1:length(parPest)){
#create presence vector
  presence=rep(0, nrow(hostPest))
  presence[which(hostPest[,'P_SP'] == parPest[i])]=1

#make some 'na' into actual NAs
  ugh=which(hostPest=='na', arr.ind=TRUE)
  hostPest[ugh]=NA

#Only train on some of the absences, since they're totally not true absences
  cutDown=c(which(presence==1), sample(which(presence==0), 5*sum(presence)))
  presence1=presence[cutDown]
  dat=hostPest[cutDown, -c(1:4)]
  hostsOfi=dat[,1]
  
#Impute the data
  impDat=rfImpute(dat[,-1], presence1)
  dat=impDat[,-1]


###### If you want to include parasite richness (or composition) ######
 psr = rowSums(intMat)
#PCA of parasite communities...otherwise you're including like 500 new variables
 pcaHosts = princomp(intMat[,-which(colnames(intMat)==parPest[i])])$scores

psrOut=vector()
pcaHostsOut=matrix(0, nrow=length(hostsOfi), ncol=5)
for(e in 1:length(hostsOfi)){
  psrOut[e] = psr[which(hostsOfi[e] == rownames(intMat))]
  pcaHostsOut[e,] = pcaHosts[which(hostsOfi[e] == rownames(intMat)), 1:5]
}

dat = data.frame(dat, psrOut, pcaHostsOut)

flag=0
 while(flag == 0){
  # This makes sure that the test set contains at least 4 hosts on which the parasite actually occurs
  inds=sample(1:nrow(dat), 0.7*nrow(dat))
  if(sum(presence1[inds]) < 4){inds[1:4] = which(presence1 == 1)[1:4]}

  #Set up a prelim train set and a test set
  train = dat[inds,]
  test = dat[-inds,]  
  if(all(unique(train$GEO) %in% unique(test$GEO))){flag=1}
 }
 
 #Presences
  prezTR=presence1[inds]
  prezTE=presence1[-inds]

  
  #baseline expectations and null models
  baseline.auc.c[i] = performance(prediction(sample(presence[-inds], length(presence[-inds])), presence[-inds]), 'auc')@y.values
  # A single occurrence prediction
  aso.auc.c[i]= performance(prediction(c(1,rep(0, length(prezTE)-1)), prezTE), 'auc')@y.values

 ##trained models
  #boosted regression trees
    brtModel.c[[i]] = gbm(prezTR ~ ., data=train, n.trees=50000, interaction.depth=4, distribution='bernoulli')
    brt.best.iter.c[[i]] = gbm.perf(brtModel.c[[i]], method="OOB")
    brt.preds.c[[i]] = prediction(predict(brtModel.c[[i]], newdata=test, n.trees=brt.best.iter.c[[i]]), prezTE)
    brt.perf.c[[i]] = performance(brt.preds.c[[i]],"tpr","fpr")
    brt.perfAUC.c[i]=unlist(performance(brt.preds.c[[i]], 'auc')@y.values)

  #support vector machines
    svmModel.c[[i]] = svm(prezTR ~ ., data=train, probability=TRUE)
    svm.preds.c[[i]] = prediction(predict(svmModel.c[[i]], test), prezTE)
    svm.perf.c[[i]] = performance(svm.preds.c[[i]],"tpr","fpr")
    svm.perfAUC.c[i] = unlist(performance(svm.preds.c[[i]], 'auc')@y.values)

  #logistic regression
    lrModel.c[[i]] = glm(prezTR ~ ., data=train, family=binomial)
    lr.preds.c[[i]] = prediction(predict(lrModel.c[[i]], test), prezTE)
    lr.perf.c[[i]] = performance(lr.preds.c[[i]],"tpr","fpr")
    lr.perfAUC.c[i] = unlist(performance(lr.preds.c[[i]], 'auc')@y.values)

  #random forest
    rfModel.c[[i]] = randomForest(prezTR ~ ., data=train)
    rf.preds.c[[i]] = prediction(predict(rfModel.c[[i]], test), prezTE)
    rf.perf.c[[i]] = performance(rf.preds.c[[i]],"tpr","fpr")
    rf.perfAUC.c[i] = unlist(performance(rf.preds.c[[i]], 'auc')@y.values)
  print(i)
  }

 ret.c=cbind(baseline.auc.c, aso.auc.c, brt.perfAUC.c, svm.perfAUC.c, lr.perfAUC.c, rf.perfAUC.c)
 colnames(ret.c)=c('BASE', 'Zero', 'BRT', 'SVM', 'LR', 'RF')
```






```{r, eval=FALSE, echo=FALSE}
#Extracting the BRT predictor variable importance values
brtResults.traits = matrix(0, ncol=length(brtModel), nrow = 5)
brtResults.geo = matrix(0, ncol=length(brtModel), nrow = 4)
brtResults.pars = matrix(0, ncol=length(brtModel), nrow = 6)
brtResults.all = matrix(0, ncol=length(brtModel), nrow = 18)

for(i in 1:length(brtModel)){
  temp1=summary(brtModel[[i]])
  brtResults.traits[,i]=temp1[order(temp1[,1]),2]
  
  temp2=summary(brtModel.geo[[i]])
  brtResults.geo[,i]=temp2[order(temp2[,1]),2]
  
  temp3=summary(brtModel.b[[i]])
  brtResults.pars[,i]=temp3[order(temp3[,1]),2]
  
  temp4=summary(brtModel.c[[i]])
  brtResults.all[,i]=temp4[order(temp4[,1]),2]

  print(i)
}

rownames(brtResults.traits) = sort(temp1[,1])
rownames(brtResults.geo) = sort(temp2[,1])
rownames(brtResults.pars) = sort(temp3[,1])
rownames(brtResults.all) = sort(temp4[,1])
```

```{r eval=F, echo=T}
#Calulate other types of accuracy measures
brt.perfAcc.traits=vector(); brt.perfAcc.geo=vector(); 
brt.perfAcc.pars=vector(); brt.perfAcc.all=vector(); 
base.perfAcc=vector()

brt.perferr.traits=vector(); brt.perferr.geo=vector(); 
brt.perferr.pars=vector(); brt.perferr.all=vector(); 
base.perferr=vector()

brt.perfmxe.traits=vector(); brt.perfmxe.geo=vector(); 
brt.perfmxe.pars=vector(); brt.perfmxe.all=vector(); 
base.perfmxe=vector()

for(z in 1:length(brtModel)){
    brt.perfAcc.traits[z] = max(unlist(performance(brt.preds[[z]],measure = 'acc')@y.values))
    brt.perfAcc.geo[z]=max(unlist(performance(brt.preds.geo[[z]],measure = 'acc')@y.values))
    brt.perfAcc.pars[z]=max(unlist(performance(brt.preds.b[[z]],measure = 'acc')@y.values))
    brt.perfAcc.all[z]=max(unlist(performance(brt.preds.c[[z]],measure = 'acc')@y.values))
    base.perfAcc[z]=max(unlist(performance(prediction(sample(presence[-inds], length(presence[-inds])), presence[-inds]), 'acc')@y.values))

    brt.perferr.traits[z] = min(unlist(performance(brt.preds[[z]],measure = 'err')@y.values))
    brt.perferr.geo[z]=min(unlist(performance(brt.preds.geo[[z]],measure = 'err')@y.values))
    brt.perferr.pars[z]=min(unlist(performance(brt.preds.b[[z]],measure = 'err')@y.values))
    brt.perferr.all[z]=min(unlist(performance(brt.preds.c[[z]],measure = 'err')@y.values))
    base.perferr[z]=min(unlist(performance(prediction(sample(presence[-inds], length(presence[-inds])), presence[-inds]), 'err')@y.values))

    brt.perfmxe.traits[z] = max(unlist(performance(brt.preds[[z]],measure = 'prec')@y.values))
    brt.perfmxe.geo[z]=max(unlist(performance(brt.preds.geo[[z]],measure = 'prec')@y.values))
    brt.perfmxe.pars[z]=max(unlist(performance(brt.preds.b[[z]],measure = 'prec')@y.values))
    brt.perfmxe.all[z]=max(unlist(performance(brt.preds.c[[z]],measure = 'prec')@y.values))
    base.perfmxe[z]=max(unlist(performance(prediction(sample(presence[-inds], length(presence[-inds])), presence[-inds]), 'prec')@y.values))

    
   print(z)

}
```






```{r eval=T, echo=T, fig.width=4, fig.height=4, tidy=TRUE}
testRet=apply(as.matrix(ret), 2, as.numeric)
testRetb=apply(as.matrix(ret.b),2, as.numeric)
testRetc=apply(as.matrix(ret.c),2, as.numeric)
testRetgeo=apply(as.matrix(ret.geo),2,as.numeric)

meanAUC = colMeans(testRet)
meanSE = apply(testRet, 2, sd) / sqrt(nrow(testRet))
meanSD = apply(testRet, 2, sd)

meanAUC.b = colMeans(testRetb)
meanSE.b = apply(testRetb, 2, sd) / sqrt(nrow(testRetb))
meanSD.b = apply(testRetb, 2, sd)

meanAUC.c = colMeans(testRetc)
meanSE.c = apply(testRetc, 2, sd) / sqrt(nrow(testRetc))
meanSD.c = apply(testRetc, 2, sd)

meanAUC.geo = colMeans(testRetgeo)
meanSE.geo = apply(testRetgeo, 2, sd) / sqrt(nrow(testRetgeo))
meanSD.geo = apply(testRetgeo, 2, sd)

brt.zero=c(meanAUC[1], meanAUC.geo[1], meanAUC.b[1], meanAUC.c[1])
brt.zero.se=c(meanSE[1], meanSE.geo[1],  meanSE.b[1], meanSE.c[1])
brt.zero.sd=c(meanSD[1], meanSD.geo[1],  meanSD.b[1], meanSD.c[1])

brt.meanAUC=c(meanAUC[3], meanAUC.geo[3],  meanAUC.b[3], meanAUC.c[3])
brt.se=c(meanSE[3], meanSE.geo[3],  meanSE.b[3], meanSE.c[3])
brt.sd=c(meanSD[3], meanSD.geo[3],  meanSD.b[3], meanSD.c[3])


plot(1:5, c(mean(brt.zero),brt.meanAUC), ylim=c(0.45, 1), xlim=c(0.7,5.3), las=1, pch=16, tck=0.01, xaxt='n', xlab='', ylab='Area under ROC curve')

abline(h=0.5, col=grey(0.5), lty=2, lwd=2)
abline(v=4.5, col=grey(0.8), lwd=1.5)
segments(x0=2:5, y0=brt.meanAUC + (brt.sd), y1=brt.meanAUC - (brt.sd), col=grey(0.8),lwd=2)
segments(x0=1, y0=mean(brt.zero)+mean(brt.zero.sd), y1=mean(brt.zero)-mean(brt.zero.sd))
points(1:5, c(mean(brt.zero),brt.meanAUC), pch=16, cex=1)
axis(1, at=1:5, labels=c('Null', 'HT',  'GEO', 'PC', 'All'), tck=0.02, lwd=1)
box()
dev.copy(pdf, width=3.6, height=3.6, '../Manuscript/Figures/brtAccuracy.pdf'); dev.off()

```






### Does predictive power differ systematically among parasites?

```{r eval=T, echo=F}
rownames(testRet) = parPest[1:238]

#Number of hosts each parasite infects
#hostNum = summary(pest[,'P_SP'])[1:238]

#Beating the data up to get parasite 'type' 
parType = unique(pest[which(pest[,'P_SP']%in% parPest[1:238]), 2:4], MARGIN=1)
parType[,1] = gsub('[*]','',parType[,1])
parType = unique(parType, MARGIN=1)
parType = parType[order(parType[,3]),]

# Hand-wavey solution to the problem of classifying parasites as two different classes of parasites 
# (C and T, or A and M). 

stupid=names(summary(parType[,3], maxsum=242)[1:3])
for(i in 1:length(stupid)){
  parType=parType[-which(parType[,3] %in% stupid[i])[1],]
}

plot(hostNum[1:238], ret[1:238,'BRT'], tck=0.01, las=1, xlab='Number host species infected', pch=16, ylab='Accuracy (AUC)')

points(hostNum[1:238], ret.geo[1:238,'BRT'], pch=16, col='skyblue')
points(hostNum[1:238], ret.b[1:238,'BRT'], pch=16, col='darkseagreen1')
points(hostNum[1:238], ret.c[1:238,'BRT'], pch=16, col='firebrick3')

lines(smooth.spline(hostNum[1:238], ret[1:238, 'BRT'], spar=0.5), lwd=4.25, col=1)
lines(smooth.spline(hostNum[1:238], ret[1:238, 'BRT'], spar=0.5), lwd=3, col=1)
lines(smooth.spline(hostNum[1:238], ret.geo[1:238, 'BRT'], spar=0.5), lwd=4.25, col=1)
lines(smooth.spline(hostNum[1:238], ret.geo[1:238, 'BRT'], spar=0.5), lwd=3, col='skyblue')
lines(smooth.spline(hostNum[1:238], ret.b[1:238, 'BRT'], spar=0.5), lwd=4.25, col=1)
lines(smooth.spline(hostNum[1:238], ret.b[1:238, 'BRT'], spar=0.5), lwd=3, col='darkseagreen1')
lines(smooth.spline(hostNum[1:238], ret.c[1:238, 'BRT'], spar=0.5), lwd=4.25, col=1)
lines(smooth.spline(hostNum[1:238], ret.c[1:238, 'BRT'], spar=0.5), lwd=3, col='firebrick3')


abline(h=0.5, col=grey(0.5,0.5), lwd=2, lty=2)
legend(100, 0.4, c('Host traits', 'Geography', 'Parasite community', 'Full model'), pch=16, col=c(1, 'skyblue','darkseagreen1', 'firebrick3'), bty='n')

dev.copy(pdf, width=5, height=5, '../Manuscript/Figures/hostNumAccuracy.pdf'); dev.off()

```




```{r eval=TRUE, echo=TRUE,fig.height=7, fig.width=7}
layout(matrix(c(1,2,3,4), ncol=2), heights=c(1,1.5))

hostCol=c('#9367B1', '#20C0D0','#719240', grey(0.5), '#D9437E')
par(mar=c(1,4,2,0.25))
plot(as.factor(parType[,1]), testRet[1:238,3], col=hostCol, tck=0.01, pch=16, las=1, ylab='Accuracy (AUC)', xaxt='n', ylim=c(0.25,1), main="Host traits")

par(mar=c(8,4,2,0.25))
plot(as.factor(parType[,1]), testRetgeo[1:238,3], col=hostCol, tck=0.01, pch=16, las=1, ylab='Accuracy (AUC)', xaxt='n', ylim=c(0.25,1), main="Geography")
parGroups=c('Acanthocephala', 'Cestoda', 'Monogenea', 'Nematoda', 'Trematoda')
axis(1, 1:5, parGroups, las=2, tck=0.01, padj=0)

par(mar=c(1,4,2,0.25))
plot(as.factor(parType[,1]), testRetb[1:238,3], col=hostCol, tck=0.01,pch=16, las=1, ylab='', xaxt='n', ylim=c(0.25,1), main="Parasite community")

par(mar=c(8,4,2,0.25))
plot(as.factor(parType[,1]), testRetc[1:238,3], col=hostCol, pch=16, tck=0.01, las=1, ylab='', xaxt='n', ylim=c(0.25,1), main="All")
parGroups=c('Acanthocephala', 'Cestoda', 'Monogenea', 'Nematoda', 'Trematoda')
axis(1, 1:5, parGroups, las=2, tck=0.01, padj=0)

dev.copy(pdf, width=5, height=5, '../Manuscript/Figures/parAccuracy.pdf'); dev.off()

```




### Are parasite distributions shaped by different factors?



#### BRT model using only host traits 

```{r eval=T, echo=T}
#varNames=c('Geographic region', 'Area of occupancy', 'Latitude', 'Max length', 'Host trophic level', 'Longitude', 'Host age at maturity', 'Host life span', 'Host growth rate', 'Marine', 'Freshwater', 'Brackish')

brtMean = rowMeans(brtResults.traits)
brtSE = apply(brtResults.traits, 1, sd) / sqrt(ncol(brtResults.traits))
brtSD = apply(brtResults.traits, 1, sd)

inds.a=order(brtMean)
par(mar=c(3,9,1,1))
plot(brtMean[inds.a], 1:5, pch=16, xlim=c(0,50), ylim=c(0.5,5.5), las=1, xlab='', ylab='', yaxt='n', col=1, tck=0.01)
segments(x0=brtMean[inds.a] - brtSD[inds.a], x1=brtMean[inds.a] + brtSD[inds.a], y0=1:5, col=grey(0.5,0.5),lwd=3)
mtext("Relative contribution", side=1, line=2)
axis(2, at=1:5, labels=c('Host growth rate', 'Host age at maturity', 'Max host age', 'Host trophic level', 'Max length'), las=1)

dev.copy(pdf, width=6, height=5, '../Manuscript/Figures/hostTraits.pdf'); dev.off()

```


```{r eval=T, echo=T}
layout(matrix(c(1,2),ncol=1), heights=c(1.5, 1))
par(mar=c(0.25,0.25,0.25,0.25))
barplot(brtResults.traits[inds.a,], col=rainbow(5), xaxt='n', axes=FALSE, border = NA)
plot.new()
legend(0.02,0.85, c('Host growth rate', 'Host age at maturity', 'Max host age', 'Host trophic level', 'Max length'), pch=16, col=rainbow(5), ncol=4, pt.cex=2, text.width=0.2)

dev.copy(pdf, width=7, height=5, '../Manuscript/Figures/hostTraitsColor.pdf'); dev.off()

```


#### BRT model using only geographic variables

```{r eval=T, echo=T}
varNames=c('Geographic region', 'Area of occupancy', 'Latitude', 'Max length', 'Host trophic level', 'Longitude', 'Host age at maturity', 'Host life span', 'Host growth rate', 'Marine', 'Freshwater', 'Brackish')
#rownames(brtResults[rev(inds),])]

brtMean = rowMeans(brtResults.geo)
brtSE = apply(brtResults.geo, 1, sd) / sqrt(ncol(brtResults.geo))
brtSD = apply(brtResults.geo, 1, sd)

inds.a=order(brtMean)
par(mar=c(3,9,1,1))
plot(brtMean[inds.a], 1:4, pch=16, xlim=c(0,45), ylim=c(0.75,4.25), las=1, xlab='', ylab='', yaxt='n', col=1, tck=0.01)
segments(x0=brtMean[inds.a] - brtSD[inds.a], x1=brtMean[inds.a] + brtSD[inds.a], y0=1:4, col=grey(0.5,0.5),lwd=3)
mtext("Relative contribution", side=1, line=2)
axis(2, at=1:4, labels=c('Latitude', 'Area of occupancy', 'Geographic region', 'Longitude'), las=1)

dev.copy(pdf, width=6, height=5, '../Manuscript/Figures/geography.pdf'); dev.off()

```


```{r eval=T, echo=T}
layout(matrix(c(1,2),ncol=1), heights=c(1.5, 1))
par(mar=c(0.25,0.25,0.25,0.25))
barplot(brtResults.geo[inds.a,], col=rainbow(5), xaxt='n', axes=FALSE, border = NA)
plot.new()
legend(0.02,0.85, c('Latitude', 'Area of occupancy', 'Geographic region', 'Longitude'), pch=16, col=rainbow(5), ncol=2, pt.cex=2, text.width=0.3)

dev.copy(pdf, width=7, height=5, '../Manuscript/Figures/geographyColor.pdf'); dev.off()

```





#### BRT models using only parasite community data (parasite species richness and a PCA of parasite community composition)

```{r eval=T, echo=T}
brtMean.b = rowMeans(brtResults.pars)
brtSE.b = apply(brtResults.pars, 1, sd) / sqrt(ncol(brtResults.pars))
brtSD.b = apply(brtResults.pars, 1, sd)

inds=order(brtMean.b)
par(mar=c(3,7,1,1))
plot(brtMean.b[inds], 1:6, pch=16, xlim=c(0,26), ylim=c(0.75,6.25), las=1, xlab='', ylab='', yaxt='n', col=1, tck=0.01)
segments(x0=brtMean.b[inds] - brtSE.b[inds], x1=brtMean.b[inds] + brtSE.b[inds], y0=1:6, col=grey(0.5, alpha=0.5),lwd=3)
mtext("Relative contribution", side=1, line=2)
axis(2, at=1:6, labels=rev(c('PCA2', 'PCA3', 'PCA5', 'PCA4', 'PCA1', 'PSR')), las=1)

dev.copy(pdf, width=6, height=5, '../Manuscript/Figures/parasiteCommunity.pdf'); dev.off()

```


```{r eval=T, echo=T, fig.width=9}
layout(matrix(c(1,2),ncol=1), heights=c(2.5, 1))
par(mar=c(0.25,0.25,0.25,0.25))
barplot(brtResults.pars[inds,], col=rainbow(6), xaxt='n', axes=FALSE, border = NA)
plot.new()
legend(0.02,0.85, rev(c('PCA2', 'PCA3', 'PCA5', 'PCA4', 'PCA1', 'PSR')), pch=16, col=rainbow(6), ncol=3, pt.cex=2, text.width=0.2)

dev.copy(pdf, width=7, height=5, '../Manuscript/Figures/parasiteCommunityColor.pdf'); dev.off()


```




#### BRT models trained on all data

```{r eval=T, echo=T, fig.height=6}
brtMean.c = rowMeans(brtResults.all)
brtSE.c = apply(brtResults.all, 1, sd) / sqrt(ncol(brtResults.all))
brtSD.c = apply(brtResults.all, 1, sd)

inds=order(brtMean.c)
par(mar=c(3,9,1,1))
plot(brtMean.c[inds], 1:15, pch=16, xlim=c(0,15), ylim=c(0.75,15.25), las=1, xlab='', ylab='', yaxt='n', col=1, tck=0.01)
segments(x0=brtMean.c[inds] - brtSE.c[inds], x1=brtMean.c[inds] + brtSE.c[inds], y0=1:18, col=grey(0.5, alpha=0.5),lwd=3)
mtext("Relative contribution", side=1, line=2)
axis(2, at=1:15, labels=c('Host growth rate', 'Lifespan', 'Host age at maturity', 'PSR', 'Longitude', 'Area of occupancy', 'Max length', 'Latitude', 'Host trophic level', 'PCA1', 'PCA4', 'PCA5', 'PCA2', 'Geographic region', 'PCA3'),las=1)

dev.copy(pdf, width=6, height=5, '../Manuscript/Figures/allData.pdf'); dev.off()
```








```{r eval=T, echo=T, fig.width=9}
cols=c('#7EC0EE',  '#32CD32', '#CD3232')
greycols=c(grey(0.75,0.5), grey(0.25,0.5), 'black')
#inds=order(brtMean.c)
inds=c(1,2,1,1,1,2,3,2,3,3,3,3,3,2,2)
layout(matrix(c(1,2),ncol=1), heights=c(2.5, 1))
par(mar=c(0.25,0.25,0.25,0.25))
barplot(brtResults.all[order(inds),], col=greycols[c(1,1,1,1,2,2,2,2,2,3,3,3,3,3,3)], xaxt='n', axes=FALSE, border = NA)

parGroups=c('Acanthocephala', 'Cestoda', 'Monogenea', 'Nematoda', 'Trematoda')

abline(v=c(30,66,81,120)*1.199, lwd=3, col='red')
plot.new()
text(15/239, 0.95 , parGroups[1],srt=0)
text(50/239, 0.95 , parGroups[2], srt=0)
text(95/239, 0.95 , parGroups[3], srt=0)
text(135/239,0.95 , parGroups[4], srt=0)
text(200/239,0.95 , parGroups[5], srt=0)

legend(0.02,0.75, c('Host traits', 'Geographic variables', 'Parasite community variables'), col=greycols, ncol=3, pt.cex=2, text.width=c(0, 0.175,0.23), pch=16, bty='n')

#legend(0.02,0.85, c('Brackish', 'Marine', 'Freshwater', 'Host growth rate', 'Lifespan', 'Host age at maturity', 'PSR', 'Longitude', 'Area of occupancy', 'Max length', 'Latitude', 'Host trophic level', 'PCA1', 'PCA4', 'PCA5', 'PCA2', 'Geographic region', 'PCA3') , pch=16, col=rainbow(20), ncol=4, pt.cex=2, text.width=0.2)

dev.copy(pdf, width=7, height=5, '../Manuscript/Figures/allDataColorGS.pdf'); dev.off()
```











## MEGA PLOT!

```{r}
layout(matrix(c(1,1,1,2,3,4), ncol=2))

#plot 1 (all traits)
brtMean.c = rowMeans(brtResults.all)
brtSE.c = apply(brtResults.all, 1, sd) / sqrt(ncol(brtResults.all))
brtSD.c = apply(brtResults.all, 1, sd)

inds=order(brtMean.c)
par(mar=c(3,9,0,0))
plot(brtMean.c[inds], 1:15, pch=16, xlim=c(0,15), ylim=c(0.75,15.25), las=1, xlab='', ylab='', yaxt='n', col=1, tck=0.01)
segments(x0=brtMean.c[inds] - brtSE.c[inds], x1=brtMean.c[inds] + brtSE.c[inds], y0=1:15, col=grey(0.5, alpha=0.5),lwd=3)
mtext("Relative contribution", side=1, line=2)
axis(2, at=1:15, labels=c('Host growth rate', 'Lifespan', 'Host age at maturity', 'Longitude', 'PSR', 'Area of occupancy', 'Host trophic level', 'Max length', 'Latitude', 'PCA1', 'PCA5', 'PCA4', 'Geographic region', 'PCA2', 'PCA3'),las=1)






#plot2 (host traits)
brtMean = rowMeans(brtResults.traits)
brtSE = apply(brtResults.traits, 1, sd) / sqrt(ncol(brtResults.traits))
brtSD = apply(brtResults.traits, 1, sd)

inds.a=order(brtMean)
par(mar=c(3,9,0,0))
plot(brtMean[inds.a], 1:5, pch=16, xlim=c(0,50), ylim=c(0.5,5.5), las=1, xlab='', ylab='', yaxt='n', col=1, tck=0.01)
segments(x0=brtMean[inds.a] - brtSD[inds.a], x1=brtMean[inds.a] + brtSD[inds.a], y0=1:5, col=grey(0.5,0.5),lwd=3)
axis(2, at=1:5, labels=c('Host growth rate', 'Host age at maturity', 'Max host age', 'Host trophic level', 'Max length'), las=1)


#plot3 (geographic vars)
brtMean = rowMeans(brtResults.geo)
brtSE = apply(brtResults.geo, 1, sd) / sqrt(ncol(brtResults.geo))
brtSD = apply(brtResults.geo, 1, sd)

inds.a=order(brtMean)
par(mar=c(3,9,0,0))
plot(brtMean[inds.a], 1:4, pch=16, xlim=c(0,45), ylim=c(0.75,4.25), las=1, xlab='', ylab='', yaxt='n', col=1, tck=0.01)
segments(x0=brtMean[inds.a] - brtSD[inds.a], x1=brtMean[inds.a] + brtSD[inds.a], y0=1:4, col=grey(0.5,0.5),lwd=3)
axis(2, at=1:4, labels=c('Latitude', 'Area of occupancy', 'Geographic region', 'Longitude'), las=1)


#plot4 (parasite community)

brtMean.b = rowMeans(brtResults.pars)
brtSE.b = apply(brtResults.pars, 1, sd) / sqrt(ncol(brtResults.pars))
brtSD.b = apply(brtResults.pars, 1, sd)

inds=order(brtMean.b)
par(mar=c(3,9,0,0))
plot(brtMean.b[inds], 1:6, pch=16, xlim=c(0,26), ylim=c(0.75,6.25), las=1, xlab='', ylab='', yaxt='n', col=1, tck=0.01)
segments(x0=brtMean.b[inds] - brtSE.b[inds], x1=brtMean.b[inds] + brtSE.b[inds], y0=1:6, col=grey(0.5, alpha=0.5),lwd=3)
mtext("Relative contribution", side=1, line=2)
axis(2, at=1:6, labels=rev(c('PCA2', 'PCA3', 'PCA5', 'PCA4', 'PCA1', 'PSR')), las=1)

dev.copy(pdf, width=6, height=4, '../Manuscript/Figures/megaBRT.pdf'); dev.off()

```



### Is this variation attributable to parasite type?

```{r fig.width=10}
layout(matrix(c(1,2),ncol=1), heights=c(1.5, 1))
par(mar=c(0.25,0.25,0.25,0.25))
inds=order(brtMean.c)
brtResults.ParType=brtResults.all[inds,order(parType[,1])]

barplot(brtResults.ParType, col=rainbow(20), xaxt='n', axes=FALSE, border = NA)
abline(v=c(30,66,81,120)*1.199, lwd=4)
plot.new()
text(15/239, 1 , parGroups[1],srt=0)
text(50/239, 1, parGroups[2], srt=0)
text(75/239, 0.95, parGroups[3], srt=0)
text(105/239, 1, parGroups[4], srt=0)
text(180/239, 1, parGroups[5], srt=0)


legend(0.02,0.85, c('Host growth rate', 'Lifespan', 'Host age at maturity', 'Longitude', 'PSR', 'Area of occupancy', 'Host trophic level', 'Max length', 'Latitude', 'PCA1', 'PCA5', 'PCA4', 'Geographic region', 'PCA2', 'PCA3') , pch=16, col=rainbow(20), ncol=4, pt.cex=2, text.width=0.2)

dev.copy(pdf, width=8, height=5, '../Manuscript/Figures/parTypeColor.pdf'); dev.off()
```






















## References 




























```{r, eval=F, echo=F}
### Does the number of hosts infected influence the relative contribution values from the boosted regression tree analysis? (no).

layout(matrix(c(1,2),ncol=1), heights=c(1.5, 1))
par(mar=c(0.25,0.25,0.25,0.25))
barplot(brtResults[,order(hostNum)], col=rainbow(15), xaxt='n', axes=FALSE, border = NA)
plot.new()
legend(0.02,0.85,varNames , pch=16, col=rainbow(15), ncol=4, pt.cex=2, text.width=0.2)


```




```{r eval=FALSE, echo=FALSE}
layout(matrix(c(1,2,3),ncol=3))
plot(1:5, meanAUC, ylim=c(0.45, 1), xlim=c(0.5,5.5), las=1, pch=16, tck=0.01, xaxt='n', xlab='Predictive model used', ylab='Area Under ROC curve', main='Host traits')
abline(h=0.5, col=grey(0.5), lty=2, lwd=2)
segments(x0=1:5, y0=meanAUC+meanSD, y1=meanAUC-meanSD, col=grey(0.8),lwd=2)
points(1:5, meanAUC, pch=16, cex=1.5)
axis(1, at=1:5, labels=c('Base', 'BRT', 'SVM', 'LR', 'RF'), tck=0.01, srt=30)

plot(1:5, meanAUC.b, ylim=c(0.45, 1), xlim=c(0.5,5.5), las=1, pch=16, tck=0.01, xaxt='n', xlab='Predictive model used', ylab='Area Under ROC curve', main='Parasite community dissimilarity')
abline(h=0.5, col=grey(0.5), lty=2, lwd=2)
segments(x0=1:5, y0=meanAUC.b+meanSD.b, y1=meanAUC.b-meanSD.b, col=grey(0.8),lwd=2)
points(1:5, meanAUC.b, pch=16, cex=1.5)
axis(1, at=1:5, labels=c('Base', 'BRT', 'SVM', 'LR', 'RF'), tck=0.01, srt=30)

plot(1:5, meanAUC.c, ylim=c(0.45, 1), xlim=c(0.5,5.5), las=1, pch=16, tck=0.01, xaxt='n', xlab='Predictive model used', ylab='Area Under ROC curve', main='Both host and parasite data')
abline(h=0.5, col=grey(0.5), lty=2, lwd=2)
segments(x0=1:5, y0=meanAUC.c+meanSD.c, y1=meanAUC.c-meanSD.c, col=grey(0.8),lwd=2)
points(1:5, meanAUC.c, pch=16, cex=1.5)
axis(1, at=1:5, labels=c('Base', 'BRT', 'SVM', 'LR', 'RF'), tck=0.01, srt=30)
```




```{r eval=FALSE, echo=F}
# storage for model outputs
baseline.auc.pal=vector(); 
brtModel.pal=list(); brt.best.iter.pal=list(); brt.preds.pal=list(); brt.perf.pal=list(); brt.perfAUC.pal=vector()
svmModel.pal=list(); svm.preds.pal=list(); svm.perf.pal=list(); svm.perfAUC.pal=vector()
lrModel.pal=list(); lr.preds.pal=list(); lr.perf.pal=list(); lr.perfAUC.pal=vector()
rfModel.pal=list(); rf.preds.pal=list(); rf.perf.pal=list(); rf.perfAUC.pal=vector()


## Creating a pointsObject
pest1 = pest[which(pest$GEO == "PAL"),]
hostPest = pest1[,-c(1:3)]

parPest = names(which(summary(pest1[,'P_SP'], maxsum=500)>20)); 
parPest = parPest[-max(length(parPest))]


for(i in 1:length(parPest)){
#create presence vector
  presence=rep(0, nrow(hostPest))
  presence[which(hostPest[,'P_SP'] == parPest[i])]=1

#make some 'na' into actual NAs
  ugh=which(hostPest=='na', arr.ind=TRUE)
  hostPest[ugh]=NA
  hostPest[,7:17]=apply(hostPest[,7:17],2, as.numeric)

#Only train on some of the absences, since they're totally not true absences
  cutDown=c(which(presence==1), sample(which(presence==0), 5*sum(presence)))
  presence1=presence[cutDown]
  dat=hostPest[cutDown, -c(1:6)]


#Impute the data
  impDat=rfImpute(dat, presence1)
  dat=impDat[,-1]

flag=0
 while(flag == 0){
  # This makes sure that the test set contains at least 4 hosts on which the parasite actually occurs
  inds=sample(1:nrow(dat), 0.7*nrow(dat))
  if(sum(presence1[inds]) < 4){inds[1:4] = which(presence1 == 1)[1:4]}

  #Set up a prelim train set and a test set
  train = dat[inds,]
  test = dat[-inds,]  
  if(all(unique(train$GEO) %in% unique(test$GEO))){flag=1}
 }
 
 #Presences
  prezTR=presence1[inds]
  prezTE=presence1[-inds]

  
  #baseline expectations and null models
  baseline.auc.pal[i] = performance(prediction(sample(presence[-inds], length(presence[-inds])), presence[-inds]), 'auc')@y.values
   
 ##trained models
  #boosted regression trees
    brtModel.pal[[i]] = gbm(prezTR ~ ., data=train, n.trees=50000, interaction.depth=4, distribution='bernoulli')
    brt.best.iter.pal[[i]] = gbm.perf(brtModel.pal[[i]], method="OOB")
    brt.preds.pal[[i]] = prediction(predict(brtModel.pal[[i]], newdata=test, n.trees=brt.best.iter.pal[[i]]), prezTE)
    brt.perf.pal[[i]] = performance(brt.preds.pal[[i]],"tpr","fpr")
    brt.perfAUC.pal[i]=unlist(performance(brt.preds.pal[[i]], 'auc')@y.values)

  #support vector machines
    svmModel.pal[[i]] = svm(prezTR ~ ., data=train, probability=TRUE)
    svm.preds.pal[[i]] = prediction(predict(svmModel.pal[[i]], test), prezTE)
    svm.perf.pal[[i]] = performance(svm.preds.pal[[i]],"tpr","fpr")
    svm.perfAUC.pal[i] = unlist(performance(svm.preds.pal[[i]], 'auc')@y.values)

  #logistic regression
    lrModel.pal[[i]] = glm(prezTR ~ ., data=train, family=binomial)
    lr.preds.pal[[i]] = prediction(predict(lrModel.pal[[i]], test), prezTE)
    lr.perf.pal[[i]] = performance(lr.preds.pal[[i]],"tpr","fpr")
    lr.perfAUC.pal[i] = unlist(performance(lr.preds.pal[[i]], 'auc')@y.values)

  #random forest
    rfModel.pal[[i]] = randomForest(prezTR ~ ., data=train)
    rf.preds.pal[[i]] = prediction(predict(rfModel.pal[[i]], test), prezTE)
    rf.perf.pal[[i]] = performance(rf.preds.pal[[i]],"tpr","fpr")
    rf.perfAUC.pal[i] = unlist(performance(rf.preds.pal[[i]], 'auc')@y.values)
  print(i)
  }

 ret.pal=cbind(baseline.auc.pal, brt.perfAUC.pal, svm.perfAUC.pal, lr.perfAUC.pal, rf.perfAUC.pal)
 colnames(ret.pal)=c('BASE', 'BRT', 'SVM', 'LR', 'RF')
```

```{r, eval=FALSE, echo=FALSE}
#Extracting the BRT predictor variable importance values
brtResults.pal=matrix(0, ncol=length(brtModel.pal), nrow=11)
for(i in 1:length(brtModel.pal)){
  temp=summary(brtModel.pal[[i]])
  brtResults.pal[,i]=temp[order(temp[,1]),2]
}
rownames(brtResults.pal) = sort(temp[,1])
```

```{r eval=FALSE, echo=F}
# storage for model outputs
baseline.auc.pal.b=vector(); 
brtModel.pal.b=list(); brt.best.iter.pal.b=list(); brt.preds.pal.b=list(); brt.perf.pal.b=list(); brt.perfAUC.pal.b=vector()
svmModel.pal.b=list(); svm.preds.pal.b=list(); svm.perf.pal.b=list(); svm.perfAUC.pal.b=vector()
lrModel.pal.b=list(); lr.preds.pal.b=list(); lr.perf.pal.b=list(); lr.perfAUC.pal.b=vector()
rfModel.pal.b=list(); rf.preds.pal.b=list(); rf.perf.pal.b=list(); rf.perfAUC.pal.b=vector()


## Creating a pointsObject
pest1 = pest[which(pest$GEO == "PAL"),]
hostPest = pest1[,-c(1:3)]

parPest = names(which(summary(pest1[,'P_SP'], maxsum=500)>20)); 
parPest = parPest[-max(length(parPest))]


for(i in 1:length(parPest)){
 #create presence vector
  presence=rep(0, nrow(hostPest))
  presence[which(hostPest[,'P_SP'] == parPest[i])]=1

#make some 'na' into actual NAs
  ugh=which(hostPest=='na', arr.ind=TRUE)
  hostPest[ugh]=NA
  hostPest[,7:17]=apply(hostPest[,7:17],2, as.numeric)


#Only train on some of the absences, since they're totally not true absences
  cutDown=c(which(presence==1), sample(which(presence==0), 5*sum(presence)))
  presence1=presence[cutDown]
  dat=hostPest[cutDown, -c(1:4)]
  hostsOfi=dat[,1]
  

###### If you want to include parasite richness (or composition) ######
 psr = rowSums(intMat)
#PCA of parasite communities...otherwise you're including like 500 new variables
pcaHosts = princomp(intMat[,-which(colnames(intMat)==parPest[i])])$scores

psrOut=vector()
pcaHostsOut=matrix(0, nrow=length(hostsOfi), ncol=10)
for(e in 1:length(hostsOfi)){
  psrOut[e] = psr[which(hostsOfi[e] == rownames(intMat))]
  pcaHostsOut[e,] = pcaHosts[which(hostsOfi[e] == rownames(intMat)), 1:10]
}

dat = data.frame(psrOut, pcaHostsOut)




  # This makes sure that the test set contains at least 4 hosts on which the parasite actually occurs
  inds=sample(1:nrow(dat), 0.7*nrow(dat))
  if(sum(presence1[inds]) < 4){inds[1:4] = which(presence1 == 1)[1:4]}

  #Set up a prelim train set and a test set
  train = dat[inds,]
  test = dat[-inds,]  
 
 
 #Presences
  prezTR=presence1[inds]
  prezTE=presence1[-inds]
  
  #baseline expectations and null models
  baseline.auc.pal.b[i] = performance(prediction(sample(presence[-inds], length(presence[-inds])), presence[-inds]), 'auc')@y.values
   
 ##trained models
  #boosted regression trees
    brtModel.pal.b[[i]] = gbm(prezTR ~ ., data=train, n.trees=50000, interaction.depth=4, distribution='bernoulli')
    brt.best.iter.pal.b[[i]] = gbm.perf(brtModel.pal.b[[i]], method="OOB")
    brt.preds.pal.b[[i]] = prediction(predict(brtModel.pal.b[[i]], newdata=test, n.trees=brt.best.iter.pal.b[[i]]), prezTE)
    brt.perf.pal.b[[i]] = performance(brt.preds.pal.b[[i]],"tpr","fpr")
    brt.perfAUC.pal.b[i]=unlist(performance(brt.preds.pal.b[[i]], 'auc')@y.values)

  #support vector machines
    svmModel.pal.b[[i]] = svm(prezTR ~ ., data=train, probability=TRUE)
    svm.preds.pal.b[[i]] = prediction(predict(svmModel.pal.b[[i]], test), prezTE)
    svm.perf.pal.b[[i]] = performance(svm.preds.pal.b[[i]],"tpr","fpr")
    svm.perfAUC.pal.b[i] = unlist(performance(svm.preds.pal.b[[i]], 'auc')@y.values)

  #logistic regression
    lrModel.pal.b[[i]] = glm(prezTR ~ ., data=train, family=binomial)
    lr.preds.pal.b[[i]] = prediction(predict(lrModel.pal.b[[i]], test), prezTE)
    lr.perf.pal.b[[i]] = performance(lr.preds.pal.b[[i]],"tpr","fpr")
    lr.perfAUC.pal.b[i] = unlist(performance(lr.preds.pal.b[[i]], 'auc')@y.values)

  #random forest
    rfModel.pal.b[[i]] = randomForest(prezTR ~ ., data=train)
    rf.preds.pal.b[[i]] = prediction(predict(rfModel.pal.b[[i]], test), prezTE)
    rf.perf.pal.b[[i]] = performance(rf.preds.pal.b[[i]],"tpr","fpr")
    rf.perfAUC.pal.b[i] = unlist(performance(rf.preds.pal.b[[i]], 'auc')@y.values)
  print(i)
  }

 ret.pal.b=cbind(baseline.auc.pal.b, brt.perfAUC.pal.b, svm.perfAUC.pal.b, lr.perfAUC.pal.b, rf.perfAUC.pal.b)
 colnames(ret)=c('BASE', 'BRT', 'SVM', 'LR', 'RF')
```

```{r eval=FALSE, echo=F}
# storage for model outputs
baseline.auc.pal.c=vector(); 
brtModel.pal.c=list(); brt.best.iter.pal.c=list(); brt.preds.pal.c=list(); brt.perf.pal.c=list(); brt.perfAUC.pal.c=vector()
svmModel.pal.c=list(); svm.preds.pal.c=list(); svm.perf.pal.c=list(); svm.perfAUC.pal.c=vector()
lrModel.pal.c=list(); lr.preds.pal.c=list(); lr.perf.pal.c=list(); lr.perfAUC.pal.c=vector()
rfModel.pal.c=list(); rf.preds.pal.c=list(); rf.perf.pal.c=list(); rf.perfAUC.pal.c=vector()


## Creating a pointsObject
pest1 = pest[which(pest$GEO == "PAL"),]
hostPest = pest1[,-c(1:3)]

parPest = names(which(summary(pest1[,'P_SP'], maxsum=500)>20)); 
parPest = parPest[-max(length(parPest))]


for(i in 1:length(parPest)){
#create presence vector
  presence=rep(0, nrow(hostPest))
  presence[which(hostPest[,'P_SP'] == parPest[i])]=1

#make some 'na' into actual NAs
  ugh=which(hostPest=='na', arr.ind=TRUE)
  hostPest[ugh]=NA
  hostPest[,7:17]=apply(hostPest[,7:17],2, as.numeric)

#Only train on some of the absences, since they're totally not true absences
  cutDown=c(which(presence==1), sample(which(presence==0), 5*sum(presence)))
  presence1=presence[cutDown]
  dat=hostPest[cutDown, -c(1:4)]
  hostsOfi=dat[,1]
  
#Impute the data
  impDat=rfImpute(dat[,-1], presence1)
  dat=impDat[,-1]


###### If you want to include parasite richness (or composition) ######
 psr = rowSums(intMat)
#PCA of parasite communities...otherwise you're including like 500 new variables
 pcaHosts = princomp(intMat[,-which(colnames(intMat)==parPest[i])])$scores

psrOut=vector()
pcaHostsOut=matrix(0, nrow=length(hostsOfi), ncol=10)
for(e in 1:length(hostsOfi)){
  psrOut[e] = psr[which(hostsOfi[e] == rownames(intMat))]
  pcaHostsOut[e,] = pcaHosts[which(hostsOfi[e] == rownames(intMat)), 1:10]
}

dat = data.frame(dat[,-1], psrOut, pcaHostsOut)

  # This makes sure that the test set contains at least 4 hosts on which the parasite actually occurs
  inds=sample(1:nrow(dat), 0.7*nrow(dat))
  if(sum(presence1[inds]) < 4){inds[1:4] = which(presence1 == 1)[1:4]}

  #Set up a prelim train set and a test set
  train = dat[inds,]
  test = dat[-inds,]  


 #Presences
  prezTR=presence1[inds]
  prezTE=presence1[-inds]

  
  #baseline expectations and null models
  baseline.auc.pal.c[i] = performance(prediction(sample(presence[-inds], length(presence[-inds])), presence[-inds]), 'auc')@y.values
   
 ##trained models
  #boosted regression trees
    brtModel.pal.c[[i]] = gbm(prezTR ~ ., data=train, n.trees=50000, interaction.depth=4, distribution='bernoulli')
    brt.best.iter.pal.c[[i]] = gbm.perf(brtModel.pal.c[[i]], method="OOB")
    brt.preds.pal.c[[i]] = prediction(predict(brtModel.pal.c[[i]], newdata=test, n.trees=brt.best.iter.pal.c[[i]]), prezTE)
    brt.perf.pal.c[[i]] = performance(brt.preds.pal.c[[i]],"tpr","fpr")
    brt.perfAUC.pal.c[i]=unlist(performance(brt.preds.pal.c[[i]], 'auc')@y.values)

  #support vector machines
    svmModel.pal.c[[i]] = svm(prezTR ~ ., data=train, probability=TRUE)
    svm.preds.pal.c[[i]] = prediction(predict(svmModel.pal.c[[i]], test), prezTE)
    svm.perf.pal.c[[i]] = performance(svm.preds.pal.c[[i]],"tpr","fpr")
    svm.perfAUC.pal.c[i] = unlist(performance(svm.preds.pal.c[[i]], 'auc')@y.values)

  #logistic regression
    lrModel.pal.c[[i]] = glm(prezTR ~ ., data=train, family=binomial)
    lr.preds.pal.c[[i]] = prediction(predict(lrModel.pal.c[[i]], test), prezTE)
    lr.perf.pal.c[[i]] = performance(lr.preds.pal.c[[i]],"tpr","fpr")
    lr.perfAUC.pal.c[i] = unlist(performance(lr.preds.pal.c[[i]], 'auc')@y.values)

  #random forest
    rfModel.pal.c[[i]] = randomForest(prezTR ~ ., data=train)
    rf.preds.pal.c[[i]] = prediction(predict(rfModel.pal.c[[i]], test), prezTE)
    rf.perf.pal.c[[i]] = performance(rf.preds.pal.c[[i]],"tpr","fpr")
    rf.perfAUC.pal.c[i] = unlist(performance(rf.preds.pal.c[[i]], 'auc')@y.values)
  print(i)
  }

 ret.pal.c=cbind(baseline.auc.pal.c, brt.perfAUC.pal.c, svm.perfAUC.pal.c, lr.perfAUC.pal.c, rf.perfAUC.pal.c)
 colnames(ret)=c('BASE', 'BRT', 'SVM', 'LR', 'RF')
```

```{r eval=F, echo=F, fig.height=3, fig.width=7}
load('/media/drakelab/Lexar/8910Project/Analysis/Rdatafiles/pest(reduced)_pal_abc.RData')
testRet.pal = as.matrix(ret.pal)
testRet.pal = apply(testRet.pal, 2, as.numeric )
meanAUC.pal = colMeans(testRet.pal)
meanSE.pal = apply(testRet.pal, 2, sd) / sqrt(nrow(testRet.pal))
meanSD.pal = apply(testRet.pal, 2, sd)
  
testRet.pal.b = as.matrix(ret.pal.b)
testRet.pal.b = apply(testRet.pal.b, 2, as.numeric )
meanAUC.pal.b = colMeans(testRet.pal.b)
meanSE.pal.b = apply(testRet.pal.b, 2, sd) / sqrt(nrow(testRet.pal.b))
meanSD.pal.b = apply(testRet.pal.b, 2, sd)
  
testRet.pal.c = as.matrix(ret.pal.c)
testRet.pal.c = apply(testRet.pal.c, 2, as.numeric )
meanAUC.pal.c = colMeans(testRet.pal.c)
meanSE.pal.c = apply(testRet.pal.c, 2, sd) / sqrt(nrow(testRet.pal.c))
meanSD.pal.c = apply(testRet.pal.c, 2, sd)



layout(matrix(c(1,2,3), ncol=3))
plot(1:5, meanAUC.pal, ylim=c(0.45, 1), xlim=c(0.5,5.5), las=1, pch=16, tck=0.01, xaxt='n', xlab='Predictive model used', ylab='Area Under ROC curve')
abline(h=0.5, col=grey(0.5), lty=2, lwd=2)
segments(x0=1:5, y0=meanAUC.pal+meanSD.pal, y1=meanAUC.pal-meanSD.pal, col=grey(0.8),lwd=2)
points(1:5, meanAUC.pal, pch=16, cex=1.5)
axis(1, at=1:5, labels=c('Base', 'BRT', 'SVM', 'LR', 'RF'), tck=0.01, srt=30)


plot(1:5, meanAUC.pal.b, ylim=c(0.45, 1), xlim=c(0.5,5.5), las=1, pch=16, tck=0.01, xaxt='n', xlab='Predictive model used', ylab='Area Under ROC curve')
abline(h=0.5, col=grey(0.5), lty=2, lwd=2)
segments(x0=1:5, y0=meanAUC.pal.b+meanSD.pal.b, y1=meanAUC.pal.b-meanSD.pal.b, col=grey(0.8),lwd=2)
points(1:5, meanAUC.pal.b, pch=16, cex=1.5)
axis(1, at=1:5, labels=c('Base', 'BRT', 'SVM', 'LR', 'RF'), tck=0.01, srt=30)

  
plot(1:5, meanAUC.pal.c, ylim=c(0.45, 1), xlim=c(0.5,5.5), las=1, pch=16, tck=0.01, xaxt='n', xlab='Predictive model used', ylab='Area Under ROC curve')
abline(h=0.5, col=grey(0.5), lty=2, lwd=2)
segments(x0=1:5, y0=meanAUC.pal.c+meanSD.pal.c, y1=meanAUC.pal.c-meanSD.pal.c, col=grey(0.8),lwd=2)
points(1:5, meanAUC.pal.c, pch=16, cex=1.5)
axis(1, at=1:5, labels=c('Base', 'BRT', 'SVM', 'LR', 'RF'), tck=0.01, srt=30)

```


```{r eval=F, echo=F}
brt.means=c(meanAUC[2], meanAUC.b[2], meanAUC.c[2], meanAUC.pal[2], meanAUC.pal.b[2], meanAUC.pal.c[2])
brt.sd = c(meanSD[2], meanSD.b[2], meanSD.c[2], meanSD.pal[2], meanSD.pal.b[2], meanSD.pal.c[2])

plot(c(1,2,3,5,6,7), brt.means, ylim=c(0.3,1), las=1, xlim=c(0.5,7.5), pch=16, tck=0.01, xlab='', ylab='', xaxt='n')
segments(x0=c(1,2,3,5,6,7), y0=brt.means+brt.sd, y1=brt.means-brt.sd)
abline(h=0.5, lty=2, lwd=2, col=grey(0.5))
abline(v=4)
axis(1, at=c(1,2,3,5,6,7), rep(c('Host', 'Parasite', 'Both'),2), tck=0.01)
box()
#mtext('', side=1, line=2)
mtext('Area under ROC curve', side=2, line=2.5)
```



```{r eval=F, echo=F}
brtMean.pal = rowMeans(brtResults.pal)
brtSE.pal = apply(brtResults.pal, 1, sd) / sqrt(ncol(brtResults.pal))
brtSD.pal = apply(brtResults.pal, 1, sd)

varNames.pal=c('Brackish', 'Freshwater', 'Host growth rate', 'Marine', 'Host age at maturity', 'Host lifespan', 'Longitude', 'Max Length', 'Host trophic level', 'Latitude', 'Area of occupancy')
#corresponds to rownames(brtResults.pal)

inds.pal=order(brtMean.pal)
par(mar=c(3,9,1,1))
plot(brtMean.pal[inds.pal], 1:11, pch=16, xlim=c(0,22), ylim=c(0.5,11.5), las=1, xlab='', ylab='', yaxt='n', col='white', tck=0.01)
segments(x0=brtMean.pal[inds.pal] - brtSE.pal[inds.pal], x1=brtMean.pal[inds.pal] + brtSE.pal[inds.pal], y0=1:11, col=grey(0.5, alpha=0.5),lwd=3)
points(brtMean.pal[inds.pal], 1:11, pch=16, cex=0.5)
mtext("Relative contribution", side=1, line=2)
axis(2, at=1:11, labels=varNames.pal, las=1, tck=0.01)

```




