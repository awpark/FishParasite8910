---
title: "What controls the range of hosts a fish parasite infects?"
author: "Tad Dallas, Andrew Park, and John M. Drake"
output:
  pdf_document: default
  html_document:
    fig_height: 6
    fig_width: 6
    highlight: tango
    theme: journal
bibliography: carp.bib
---


```{r echo=FALSE, message=FALSE, comment=FALSE}
## Load in some data and required packages
library(rfishbase); library(gbm); library(ROCR); library(e1071); library(randomForest)
```


## Introduction





### Knowledge gap

What constrains the range of hosts that a parasite can infect? Is there a simple range of host functional traits that can determine the likelihood that a parasite infects a given host species? How well can we predict parasite occurrences given _only_ some host life history traits? Does the importance of different host functional traits differ with parasite type?



### Thesis paragraph

Here, I apply a series of predictive models in order to predict parasite occurrence across a range of potential host species for a large set of parasites of freshwater fish, using host functional traits, and geographic location. 




### thorns in my side:

* Absence data aren't true absences. Should I even train on these data if the model treats them as true absences?

* How much time to invest reading density estimation literature? 




## Methods

### Data and processing
 We use an existing global database of fish-parasite associations [@strona2013] consisting of over 38000 parasite records spanning a large diversity of parasites (Acanthocephala, Cestoda, Monogenea, Nematoda, Trematoda). In order to allow for cross-validation and accurate prediction, we constrained our ananlyses to parasites with a minimum of 50 host records. In other words, we only examined parasites that had been recorded more than 50 times, but these occurrences could be on fewer than 50 host species. The inclusion of duplicate occurrences was only permitted if the parasite was recorded on a host in a different location, based on latitude and longitude values. Our response variable was parasite occurrence (binary), and was predicted using only host life history traits, and geographic location of host capture. Host trait information was obtained through the FishPest database [@strona2012; @strona2013], and FishBase [@froese2010]. Host traits descriptions are provided in Table 1
 
 
### Model formulation 
  We trained a series of models in order to compare predictive performance of different techniques. Each model was trained on 70% of the data, and accuracy was determined from the remaining 30%. This process was repeated $z$ times ($z$ = 20). We generated background data by randomly sampling host species where parasite $i$ was not recorded. To maintain proportional training data, the number of random samples was selected to be five times greater than the occurrence records. 
  
### Models used
 discuss null predictions scenario, and then go into other algorithms used (brt, svm, lr, rf)







### Strona's FishPest database

```{r, eval=FALSE, echo=TRUE, message=FALSE}
#load('/media/drakelab/Lexar/8910Project/Analysis/pest.Rdata')

## Creating a `fishMatrix` equiv.
#edgePest=edge2matrix(cbind(pest[,'H_SP'], pest[,'P_SP']))
#colnames(edgePest)=unique(pest[,'P_SP'])
#rownames(edgePest)=unique(pest[,'H_SP'])
#edgePest=edgePest[,-which(colSums(edgePest) < 50)]


library(rfishbase); library(gbm); library(ROCR); library(e1071); library(randomForest)
# storage for model outputs
baseline.auc=vector(); 
brtModel=list(); brt.best.iter=list(); brt.preds=list(); brt.perf=list(); brt.perfAUC=vector()
svmModel=list(); svm.preds=list(); svm.perf=list(); svm.perfAUC=vector()
lrModel=list(); lr.preds=list(); lr.perf=list(); lr.perfAUC=vector()
rfModel=list(); rf.preds=list(); rf.perf=list(); rf.perfAUC=vector()


## Creating a pointsObject
#hostPest = unique(pest[,-c(1:3)], MARGIN=1)
hostPest = pest[,-c(1:3)]
parPest = names(summary(pest[,'P_SP'], maxsum=500)>20); 
parPest=parPest[-max(length(parPest))]

ret=list()
for(i in 1:length(parPest)){
#create presence vector
  presence=rep(0, nrow(hostPest))
  presence[which(hostPest[,'P_SP'] == parPest[i])]=1

#make some 'na' into actual NAs
  ugh=which(hostPest=='na', arr.ind=TRUE)
  hostPest[ugh]=NA
  hostPest[,7:17]=apply(hostPest[,7:17],2, as.numeric)

#Only train on some of the absences, since they're totally not true absences
  cutDown=c(which(presence==1), sample(which(presence==0), 5*sum(presence)))
  presence1=presence[cutDown]
  dat=hostPest[cutDown, -c(1,5)]

#Impute the data
  impDat=rfImpute(dat[,-c(1:3)], presence1)
  dat=impDat[,-1]

flag=0
 while(flag == 0){
  # This makes sure that the test set contains at least 4 hosts on which the parasite actually occurs
  inds=sample(1:nrow(dat), 0.7*nrow(dat))
  if(sum(presence1[inds]) < 4){inds[1:4] = which(presence1 == 1)[1:4]}

  #Set up a prelim train set and a test set
  train = dat[inds,]
  test = dat[-inds,]  
  if(all(unique(train$GEO) %in% unique(test$GEO))){flag=1}
 }
 
 #Presences
  prezTR=presence1[inds]
  prezTE=presence1[-inds]

  
  #baseline expectations and null models
  baseline.auc[i] = performance(prediction(sample(presence[-inds], length(presence[-inds])), presence[-inds]), 'auc')@y.values
   
 ##trained models
  #boosted regression trees
    brtModel[[i]] = gbm(prezTR ~ ., data=train, n.trees=50000, interaction.depth=4, distribution='bernoulli')
    brt.best.iter[[i]] = gbm.perf(brtModel[[i]], method="OOB")
    brt.preds[[i]] = prediction(predict(brtModel[[i]], newdata=test, n.trees=brt.best.iter[[i]]), prezTE)
    brt.perf[[i]] = performance(brt.preds[[i]],"tpr","fpr")
    brt.perfAUC[i]=unlist(performance(brt.preds[[i]], 'auc')@y.values)

  #support vector machines
    svmModel[[i]] = svm(prezTR ~ ., data=train, probability=TRUE)
    svm.preds[[i]] = prediction(predict(svmModel[[i]], test), prezTE)
    svm.perf[[i]] = performance(svm.preds[[i]],"tpr","fpr")
    svm.perfAUC[i] = unlist(performance(svm.preds[[i]], 'auc')@y.values)

  #logistic regression
    lrModel[[i]] = glm(prezTR ~ ., data=train, family=binomial)
    lr.preds[[i]] = prediction(predict(lrModel[[i]], test), prezTE)
    lr.perf[[i]] = performance(lr.preds[[i]],"tpr","fpr")
    lr.perfAUC[i] = unlist(performance(lr.preds[[i]], 'auc')@y.values)

  #random forest
    rfModel[[i]] = randomForest(prezTR ~ ., data=train)
    rf.preds[[i]] = prediction(predict(rfModel[[i]], test), prezTE)
    rf.perf[[i]] = performance(rf.preds[[i]],"tpr","fpr")
    rf.perfAUC[i] = unlist(performance(rf.preds[[i]], 'auc')@y.values)
  print(i)
  }

 ret=cbind(baseline.auc[1:241], brt.perfAUC[1:241], svm.perfAUC[1:241], lr.perfAUC[1:241], rf.perfAUC[1:241])
 colnames(ret)=c('BASE', 'BRT', 'SVM', 'LR', 'RF')
 
 
```

```{r, eval=FALSE, echo=FALSE}
#Extracting the BRT predictor variable importance values
brtResults=matrix(0, ncol=length(brtModel), nrow=12)
for(i in 1:length(brtModel)){
  temp=summary(brtModel[[i]])
  brtResults[,i]=temp[order(temp[,1]),2]
}
rownames(brtResults) = sort(temp[,1])
```


```{r eval=T, echo=T}
load('/media/drakelab/Lexar/8910Project/Analysis/pest(reduced).RData')
testRet=as.matrix(ret)
testRet=apply(testRet,2, as.numeric )
meanAUC = colMeans(testRet)
meanSE = apply(testRet, 2, sd) / sqrt(nrow(testRet))
meanSD = apply(testRet, 2, sd)
  
plot(1:5, meanAUC, ylim=c(0.45, 1), xlim=c(0.5,5.5), las=1, pch=16, tck=0.01, xaxt='n', xlab='Predictive model used', ylab='Area Under ROC curve')
abline(h=0.5, col=grey(0.5), lty=2, lwd=2)
segments(x0=1:5, y0=meanAUC+meanSD, y1=meanAUC-meanSD, col=grey(0.8),lwd=2)
points(1:5, meanAUC, pch=16, cex=1.5)
axis(1, at=1:5, labels=c('Base', 'BRT', 'SVM', 'LR', 'RF'), tck=0.01, srt=30)

```




### Does predictive power differ systematically among parasites?

```{r eval=F, echo=T}
rownames(testRet) = parPest[1:241]

#Number of hosts each parasite infects
hostNum = summary(pest[,'P_SP'])[1:241]

#Beating the data up to get parasite 'type' 
parType = unique(pest[which(pest[,'P_SP']%in% parPest[1:241]), 2:4], MARGIN=1)
parType[,1] = gsub('[*]','',parType[,1])
parType = unique(parType, MARGIN=1)
parType = parType[order(parType[,3]),]

# Hand-wavey solution to the problem of classifying parasites as two different classes of parasites 
# (C and T, or A and M). 

stupid=names(summary(parType[,3], maxsum=242)[1:3])
for(i in 1:length(stupid)){
  parType=parType[-which(parType[,3] %in% stupid[i])[1],]
}

```


### Are parasite distributions shaped by different factors?

```{r eval=T, echo=T}
varNames=c('Geographic region', 'Area of occupancy', 'Latitude', 'Max length', 'Host trophic level', 'Longitude', 'Host age at maturity', 'Host life span', 'Host growth rate', 'Marine', 'Freshwater', 'Brackish')
#rownames(brtResults[rev(inds),])


brtMean = rowMeans(brtResults)
brtSE = apply(brtResults, 1, sd) / sqrt(ncol(brtResults))
brtSD = apply(brtResults, 1, sd)

inds=order(brtMean)
cols=rev(c(1,1,1,2,2,1,2,2,2,2,2,2))
par(mar=c(3,9,1,1))
plot(brtMean[inds], 1:12, pch=16, xlim=c(0,26), ylim=c(0.5,12.5), las=1, xlab='', ylab='', yaxt='n', col=cols, tck=0.01)
segments(x0=brtMean[inds] - brtSE[inds], x1=brtMean[inds] + brtSE[inds], y0=1:12, col=cols,lwd=3)
mtext("Relative contribution", side=1, line=2)
axis(2, at=1:12, labels=rev(varNames), las=1)
```




```{r eval=T, echo=T, fig.width=9}
layout(matrix(c(1,2),ncol=1), heights=c(1.5, 1))
par(mar=c(0.25,0.25,0.25,0.25))
barplot(brtResults[rev(inds),], col=rainbow(15), xaxt='n', axes=FALSE, border = NA)
plot.new()
legend(0.02,0.85,varNames , pch=16, col=rainbow(15), ncol=4, pt.cex=2, text.width=0.2)
```


## Results









## Discussion



## Tables

Table 1: Host traits examined and their corresponding units

Table 2: Details for parasites modeled, including number of occurrences, and life history information.


## Figures








## References 







```{r, message=FALSE, eval=FALSE, echo=FALSE}
#### DEPRECATED CODE #### 
#load('/media/drakelab/Lexar/8910Project/Analysis/fishParty(reduced).RData')
#load('/media/drakelab/Lexar/8910Project/Analysis/fishParty.RData')
# list of imputed data matrices
m.imputedData=list()

# storage for model outputs
m.baseline.auc=vector(); 
m.brtModel=list(); m.brt.best.iter=list(); m.brt.preds=list(); m.brt.perf=list(); m.brt.perfAUC=vector()
m.svmModel=list(); m.svm.preds=list(); m.svm.perf=list(); m.svm.perfAUC=vector()
m.lrModel=list(); m.lr.preds=list(); m.lr.perf=list(); m.lr.perfAUC=vector()
m.rfModel=list(); m.rf.preds=list(); m.rf.perf=list(); m.rf.perfAUC=vector()



for(i in 1:nrow(marineMatrix3)){
#data imputation
  dat = getPointsObject(marineMatrix3[i,], MT)
  dat = rfImpute(dat[,-1], dat[,1])
  m.imputedData[[i]] = dat
    
 #This makes sure that the test set contains at least 4 hosts on which the parasite actually occurs
  pres=which(dat[,1]==1)
  inds=sample(1:nrow(dat), 0.7*nrow(dat))
  if(sum(pres %in% inds) < 4){inds[1:4]=pres[1:4]}
  train = dat[inds,]
  test = dat[-inds,]
  
  #baseline expectations and null models
  m.baseline.auc[i] = performance(prediction(test[sample(1:nrow(test), nrow(test)),1], test[,1]), 'auc')@y.values
   
 ##trained models
  #boosted regression trees
  weights=1 / (sum(train[,1])/nrow(train))
  m.brtModel[[i]] = gbm(train[,1] ~ ., data=train[,-1], n.trees=50000, interaction.depth=4, distribution='bernoulli', weights=1+(train[,1] * weights))
  m.brt.best.iter[[i]] = gbm.perf(m.brtModel[[i]], method="OOB")
  m.brt.preds[[i]] = prediction(predict(m.brtModel[[i]], newdata=test[,-1], n.trees=m.brt.best.iter[[i]]), test[,1])
  m.brt.perf[[i]] = performance(m.brt.preds[[i]],"tpr","fpr")
  m.brt.perfAUC[i]=unlist(performance(m.brt.preds[[i]], 'auc')@y.values)

  #support vector machines
  m.svmModel[[i]] = svm(train[,1] ~ ., data=train[,-1])
  m.svm.preds[[i]] = prediction(predict(m.svmModel[[i]], test[,-1]), test[,1])
  m.svm.perf[[i]] = performance(m.svm.preds[[i]],"tpr","fpr")
  m.svm.perfAUC[i] = unlist(performance(m.svm.preds[[i]], 'auc')@y.values)

  #logistic regression
  m.lrModel[[i]] = glm(train[,1] ~ ., data=train[,-1], family=binomial)
  m.lr.preds[[i]] = prediction(predict(m.lrModel[[i]], test[,-1]), test[,1])
  m.lr.perf[[i]] = performance(m.lr.preds[[i]],"tpr","fpr")
  m.lr.perfAUC[i] = unlist(performance(m.lr.preds[[i]], 'auc')@y.values)

  #random forest
  m.rfModel[[i]] = randomForest(train[,1] ~ ., data=train[,-1])
  m.rf.preds[[i]] = prediction(predict(m.rfModel[[i]], test[,-1]), test[,1])
  m.rf.perf[[i]] = performance(m.rf.preds[[i]],"tpr","fpr")
  m.rf.perfAUC[i] = unlist(performance(m.rf.preds[[i]], 'auc')@y.values)
  
  print(i)
}



```

```{r, echo=FALSE, eval=FALSE, echo=FALSE}
#find all unique host species
fresh=fish[which(fish[,1] %in% unique(fish[,1])[c(1,4,6,7)]),]
marine=fish[which(fish[,1] %in% unique(fish[,1])[c(2,3)]),]

freshfish=unique(fresh$Host.fish.species); marinefish=unique(marine$Host.fish.species)
freshIndices=findSpecies(freshfish); marineIndices=findSpecies(marinefish)

# Get trait information
freshtraits=getQuantTraits(fish.data[freshIndices])
marinetraits=getQuantTraits(fish.data[marineIndices])

freshsize=cbind(getSize(fish.data[freshIndices], value='age'), getSize(fish.data[freshIndices], 'weight'), getSize(fish.data[freshIndices], 'length')); colnames(freshsize)=c('age', 'weight', 'length')

marinesize=cbind(getSize(fish.data[marineIndices], value='age'), getSize(fish.data[marineIndices], 'weight'), getSize(fish.data[marineIndices], 'length')); colnames(marinesize)=c('age', 'weight', 'length')

freshdepth=getDepth(fish.data[freshIndices])
marinedepth=getDepth(fish.data[marineIndices])

#format some trait matrices, and then remove any variables missing more than 90% observations
FT = cbind(freshtraits, freshsize, freshdepth)
FT = FT[,-which(colSums(is.na(FT)) > 500)]
MT = cbind(marinetraits, marinesize, marinedepth)
MT = MT[,-which(colSums(is.na(MT)) > 700)]

rownames(FT)=sub('_', ' ', rownames(FT))
rownames(MT)=sub('_', ' ', rownames(MT))
```

```{r, echo=FALSE, eval=FALSE, echo=FALSE}
#Data processing and support functions
edge2matrix=function(edgelist){
 return(table(edgelist[,1], edgelist[,2]))
}

# takes a matrix and returns an edgelist, where multiple reports are weighted by the number of entries in the resulting edgelist
matrix2edge=function(matrix, quant=TRUE){
   if(quant==FALSE){return(which(matrix>0, arr.ind=TRUE))
   }else{
    max=max(matrix)
    ret=list()
    for(i in 1:max){
      inds=which(matrix == i, arr.ind=TRUE)
      inds2=do.call("rbind", replicate(i, inds, simplify = FALSE))
      those=matrix(c(rownames(matrix)[inds2[,1]], colnames(matrix)[inds2[,2]]), ncol=2)
      ret[[i]]=those
    }
    ret2=matrix(unlist(ret), ncol=2, byrow=FALSE)
    colnames(ret2)=c('Host', 'Parasite')
    return(ret2)
   }
}


freshParasite = paste(gsub(' ', '', fresh[,3]), gsub(' ','', fresh[,4]), sep=' ')
freshParasite= gsub('Â', '', freshParasite)
freshHosts=sub('_', ' ',rownames(FT))

marineParasite = paste(gsub(' ', '', marine[,3]), gsub(' ','', marine[,4]), sep=' ')
marineParasite = gsub('Â', '', marineParasite)
marineHosts=sub('_', ' ', rownames(MT))

freshPotentialHosts=gsub('Â', '', fresh[,'Host.fish.species'])
freshPotentialHosts=gsub("^\\s+|\\s+$", "", freshPotentialHosts) 

marinePotentialHosts=gsub('Â', '', marine[,'Host.fish.species'])
marinePotentialHosts=gsub("^\\s+|\\s+$", "", marinePotentialHosts)

freshMatrix=edge2matrix(data.frame(parasite=freshParasite, host=freshPotentialHosts))
marineMatrix=edge2matrix(data.frame(parasite=marineParasite, host=marinePotentialHosts))

#set threshold of presence points to consider (n=5)
freshMatrix2=freshMatrix[which(rowSums(freshMatrix>0) > 25),]
freshMatrix3=freshMatrix2[, which(colnames(freshMatrix2) %in% freshHosts)]

marineMatrix2=marineMatrix[which(rowSums(marineMatrix>0) > 25),]
marineMatrix3=marineMatrix2[, which(colnames(marineMatrix2) %in% marineHosts)]



getPointsObject=function(parRow, hostTraits, binary=TRUE){
  hostTraits=hostTraits[order(rownames(hostTraits)),]
  inds=(rownames(hostTraits) %in% names(which(parRow>0)))
  occVec = rep(0, nrow(hostTraits))
  occVec[inds] = parRow[which(parRow>0)]
  if(binary==TRUE){occVec=0+(occVec>0)}
  return(data.frame(presence = occVec, hostTraits)) 
}


```

```{r, message=FALSE, eval=FALSE, echo=F}
getModels=function(fishMatrix, traitMatrix){
  # list of imputed data matrices
  imputedData=list()
  # storage for model outputs
  baseline.auc=vector(); 
  brtModel=list(); brt.best.iter=list(); brt.preds=list(); brt.perf=list(); brt.perfAUC=vector()
  svmModel=list(); svm.preds=list(); svm.perf=list(); svm.perfAUC=vector()
  lrModel=list(); lr.preds=list(); lr.perf=list(); lr.perfAUC=vector()
  rfModel=list(); rf.preds=list(); rf.perf=list(); rf.perfAUC=vector()

  for(i in 1:nrow(fishMatrix)){
    #data imputation
    dat = getPointsObject(fishMatrix[i,], traitMatrix)
    dat = rfImpute(dat[,-1], dat[,1])
    imputedData[[i]] = dat
  
  # This makes sure that the test set contains at least 4 hosts on which the parasite actually occurs
    pres=which(dat[,1]==1)
    inds=sample(1:nrow(dat), 0.7*nrow(dat))
    if(sum(pres %in% inds) < 4){inds[1:4]=pres[1:4]}
  
    train = dat[inds,]
    test = dat[-inds,]
  
  #baseline expectations and null models
    baseline.auc[i] = performance(prediction(test[sample(1:nrow(test), nrow(test)),1], test[,1]), 'auc')@y.values
   
 ##trained models
  #boosted regression trees
    weights=1/(sum(train[,1])/nrow(train))
    brtModel[[i]] = gbm(train[,1] ~ ., data=train[,-1], n.trees=60000, interaction.depth=4, distribution='bernoulli', weights=1+(train[,1] * weights))
    brt.best.iter[[i]] = gbm.perf(brtModel[[i]], method="OOB")
    brt.preds[[i]] = prediction(predict(brtModel[[i]], newdata=test[,-1], n.trees=brt.best.iter[[i]]), test[,1])
    brt.perf[[i]] = performance(brt.preds[[i]],"tpr","fpr")
    brt.perfAUC[i]=unlist(performance(brt.preds[[i]], 'auc')@y.values)

  #support vector machines
    svmModel[[i]] = svm(train[,1] ~ ., data=train[,-1], probability=TRUE)
    svm.preds[[i]] = prediction(predict(svmModel[[i]], test[,-1]), test[,1])
    svm.perf[[i]] = performance(svm.preds[[i]],"tpr","fpr")
    svm.perfAUC[i] = unlist(performance(svm.preds[[i]], 'auc')@y.values)

  #logistic regression
    lrModel[[i]] = glm(train[,1] ~ ., data=train[,-1], family=binomial)
    lr.preds[[i]] = prediction(predict(lrModel[[i]], test[,-1]), test[,1])
    lr.perf[[i]] = performance(lr.preds[[i]],"tpr","fpr")
    lr.perfAUC[i] = unlist(performance(lr.preds[[i]], 'auc')@y.values)

  #random forest
    rfModel[[i]] = randomForest(train[,1] ~ ., data=train[,-1])
    rf.preds[[i]] = prediction(predict(rfModel[[i]], test[,-1]), test[,1])
    rf.perf[[i]] = performance(rf.preds[[i]],"tpr","fpr")
    rf.perfAUC[i] = unlist(performance(rf.preds[[i]], 'auc')@y.values)
  print(i)
  }
 ret=cbind(baseline.auc, brt.perfAUC, svm.perfAUC, lr.perfAUC, rf.perfAUC)
 colname(ret)=c('BASE', 'BRT', 'SVM', 'LR', 'RF')
return()
}



## get models for freshwater and marine parasites
freshOut=getModels(freshMatrix3, FT)
marineOut=getModels(marineMatrix3, MT)
```

```{r eval=F, echo=FALSE}

meanAUC=colMeans(freshOut)
meanSE = apply(freshOut,2,sd) / sqrt(nrow(freshOut))
meanSD = apply(freshOut,2,sd)
  
plot(1:5, meanAUC, ylim=c(0.45, 1), xlim=c(0.5,5.5), las=1, pch=16, tck=0.01, xaxt='n', xlab='Predictive model used', ylab='Area Under ROC curve')
abline(h=0.5, col=grey(0.5), lty=2, lwd=2)
segments(x0=1:5, y0=meanAUC+meanSD, y1=meanAUC-meanSD, col=grey(0.8),lwd=2)
points(1:5, meanAUC, pch=16, cex=1.5)
axis(1, at=1:5, labels=c('Base', 'BRT', 'SVM', 'LR', 'RF'), tck=0.01, srt=30)

```

```{r eval=F, echo=FALSE}

meanAUC=colMeans(marineOut)
meanSE = apply(marineOut,2,sd) / sqrt(nrow(marineOut))
meanSD = apply(marineOut,2,sd)
  
  
plot(1:5, m.meanAUC, ylim=c(0.45, 1), xlim=c(0.5,5.5), las=1, pch=16, tck=0.01, xaxt='n', xlab='Predictive model used', ylab='Area Under ROC curve')
abline(h=0.5, col=grey(0.5), lty=2, lwd=2)
segments(x0=1:5, y0=m.meanAUC+m.meanSD, y1=m.meanAUC-m.meanSD, col=grey(0.8),lwd=2)
points(1:5, m.meanAUC, pch=16, cex=1.5)
axis(1, at=1:5, labels=c('Base', 'BRT', 'SVM', 'LR', 'RF'), tck=0.01, srt=30)

```


