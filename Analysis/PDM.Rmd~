---
title: "Parasite species distribution modeling"
author: "Tad Dallas, Andrew Park, and John M. Drake"
output:
  html_document:
    fig_height: 6
    fig_width: 6
    highlight: tango
    theme: journal
  pdf_document: default
---


```{r, echo=FALSE, message=FALSE, comment=FALSE}
#fish=read.csv('/media/drakelab/Lexar/HostParasiteRCN/Data/Fish/parasiteTraits.csv')
#load('/media/drakelab/Lexar/8910Project/Analysis/fishParty(reduced).RData')
#load('/media/drakelab/Lexar/8910Project/Analysis/fishParty.RData')
library(rfishbase); library(gbm); library(ROCR); library(e1071); library(randomForest)
```


## Introduction




### Knowledge gap
What constrains the range of hosts that a parasite can infect? Is there a simple range of host functional traits that can determine the likelihood that a parasite infects a given host species?

Here, I develop predictive models based on host functional traits, and geographic location, to determine the host breadth for a large set of parasites of freshwater fish. 




### thorns in my side:

* Validation, validation, validation.
* Absence data aren't true absences. Should I even train on these data if the model treats them as true absences?
* How much time to invest reading density estimation literature? I may be able to code out a SDM version of  uLSIF 





## Methods

### Data and processing
 what the data are (fish-parasite data obtained from FishBase, and Strona's FishPest database)
 data selection, row removal, and imputation
 
 
 
### Models used
 discuss null predictions scenario, and then go into other algorithms used (brt, svm, lr, rf)




```{r, echo=FALSE, eval=FALSE}
#find all unique host species
fresh=fish[which(fish[,1] %in% unique(fish[,1])[c(1,4,6,7)]),]
marine=fish[which(fish[,1] %in% unique(fish[,1])[c(2,3)]),]

freshfish=unique(fresh$Host.fish.species); marinefish=unique(marine$Host.fish.species)
freshIndices=findSpecies(freshfish); marineIndices=findSpecies(marinefish)

# Get trait information
freshtraits=getQuantTraits(fish.data[freshIndices])
marinetraits=getQuantTraits(fish.data[marineIndices])

freshsize=cbind(getSize(fish.data[freshIndices], value='age'), getSize(fish.data[freshIndices], 'weight'), getSize(fish.data[freshIndices], 'length')); colnames(freshsize)=c('age', 'weight', 'length')

marinesize=cbind(getSize(fish.data[marineIndices], value='age'), getSize(fish.data[marineIndices], 'weight'), getSize(fish.data[marineIndices], 'length')); colnames(marinesize)=c('age', 'weight', 'length')

freshdepth=getDepth(fish.data[freshIndices])
marinedepth=getDepth(fish.data[marineIndices])

#format some trait matrices, and then remove any variables missing more than 90% observations
FT = cbind(freshtraits, freshsize, freshdepth)
FT = FT[,-which(colSums(is.na(FT)) > 500)]
MT = cbind(marinetraits, marinesize, marinedepth)
MT = MT[,-which(colSums(is.na(MT)) > 700)]

rownames(FT)=sub('_', ' ', rownames(FT))
rownames(MT)=sub('_', ' ', rownames(MT))
```


```{r, echo=FALSE, eval=FALSE}
#Data processing and support functions
edge2matrix=function(edgelist){
 return(table(edgelist[,1], edgelist[,2]))
}

# takes a matrix and returns an edgelist, where multiple reports are weighted by the number of entries in the resulting edgelist
matrix2edge=function(matrix, quant=TRUE){
   if(quant==FALSE){return(which(matrix>0, arr.ind=TRUE))
   }else{
    max=max(matrix)
    ret=list()
    for(i in 1:max){
      inds=which(matrix == i, arr.ind=TRUE)
      inds2=do.call("rbind", replicate(i, inds, simplify = FALSE))
      those=matrix(c(rownames(matrix)[inds2[,1]], colnames(matrix)[inds2[,2]]), ncol=2)
      ret[[i]]=those
    }
    ret2=matrix(unlist(ret), ncol=2, byrow=FALSE)
    colnames(ret2)=c('Host', 'Parasite')
    return(ret2)
   }
}


freshParasite = paste(gsub(' ', '', fresh[,3]), gsub(' ','', fresh[,4]), sep=' ')
freshParasite= gsub('Â', '', freshParasite)
freshHosts=sub('_', ' ',rownames(FT))

marineParasite = paste(gsub(' ', '', marine[,3]), gsub(' ','', marine[,4]), sep=' ')
marineParasite = gsub('Â', '', marineParasite)
marineHosts=sub('_', ' ', rownames(MT))

freshPotentialHosts=gsub('Â', '', fresh[,'Host.fish.species'])
freshPotentialHosts=gsub("^\\s+|\\s+$", "", freshPotentialHosts) 

marinePotentialHosts=gsub('Â', '', marine[,'Host.fish.species'])
marinePotentialHosts=gsub("^\\s+|\\s+$", "", marinePotentialHosts)

freshMatrix=edge2matrix(data.frame(parasite=freshParasite, host=freshPotentialHosts))
marineMatrix=edge2matrix(data.frame(parasite=marineParasite, host=marinePotentialHosts))

#set threshold of presence points to consider (n=5)
freshMatrix2=freshMatrix[which(rowSums(freshMatrix>0) > 25),]
freshMatrix3=freshMatrix2[, which(colnames(freshMatrix2) %in% freshHosts)]

marineMatrix2=marineMatrix[which(rowSums(marineMatrix>0) > 25),]
marineMatrix3=marineMatrix2[, which(colnames(marineMatrix2) %in% marineHosts)]



getPointsObject=function(parRow, hostTraits, binary=TRUE){
  hostTraits=hostTraits[order(rownames(hostTraits)),]
  inds=(rownames(hostTraits) %in% names(which(parRow>0)))
  occVec = rep(0, nrow(hostTraits))
  occVec[inds] = parRow[which(parRow>0)]
  if(binary==TRUE){occVec=0+(occVec>0)}
  return(data.frame(presence = occVec, hostTraits)) 
}


```




```{r, message=FALSE, eval=FALSE, echo=TRUE}
getModels=function(fishMatrix, traitMatrix){
  # list of imputed data matrices
  imputedData=list()
  # storage for model outputs
  baseline.auc=vector(); 
  brtModel=list(); brt.best.iter=list(); brt.preds=list(); brt.perf=list(); brt.perfAUC=vector()
  svmModel=list(); svm.preds=list(); svm.perf=list(); svm.perfAUC=vector()
  lrModel=list(); lr.preds=list(); lr.perf=list(); lr.perfAUC=vector()
  rfModel=list(); rf.preds=list(); rf.perf=list(); rf.perfAUC=vector()

  for(i in 1:nrow(fishMatrix)){
    #data imputation
    dat = getPointsObject(fishMatrix[i,], traitMatrix)
    dat = rfImpute(dat[,-1], dat[,1])
    imputedData[[i]] = dat
  
  # This makes sure that the test set contains at least 4 hosts on which the parasite actually occurs
    pres=which(dat[,1]==1)
    inds=sample(1:nrow(dat), 0.7*nrow(dat))
    if(sum(pres %in% inds) < 4){inds[1:4]=pres[1:4]}
  
    train = dat[inds,]
    test = dat[-inds,]
  
  #baseline expectations and null models
    baseline.auc[i] = performance(prediction(test[sample(1:nrow(test), nrow(test)),1], test[,1]), 'auc')@y.values
   
 ##trained models
  #boosted regression trees
    weights=1/(sum(train[,1])/nrow(train))
    brtModel[[i]] = gbm(train[,1] ~ ., data=train[,-1], n.trees=60000, interaction.depth=4, distribution='bernoulli', weights=1+(train[,1] * weights))
    brt.best.iter[[i]] = gbm.perf(brtModel[[i]], method="OOB")
    brt.preds[[i]] = prediction(predict(brtModel[[i]], newdata=test[,-1], n.trees=brt.best.iter[[i]]), test[,1])
    brt.perf[[i]] = performance(brt.preds[[i]],"tpr","fpr")
    brt.perfAUC[i]=unlist(performance(brt.preds[[i]], 'auc')@y.values)

  #support vector machines
    svmModel[[i]] = svm(train[,1] ~ ., data=train[,-1], probability=TRUE)
    svm.preds[[i]] = prediction(predict(svmModel[[i]], test[,-1]), test[,1])
    svm.perf[[i]] = performance(svm.preds[[i]],"tpr","fpr")
    svm.perfAUC[i] = unlist(performance(svm.preds[[i]], 'auc')@y.values)

  #logistic regression
    lrModel[[i]] = glm(train[,1] ~ ., data=train[,-1], family=binomial)
    lr.preds[[i]] = prediction(predict(lrModel[[i]], test[,-1]), test[,1])
    lr.perf[[i]] = performance(lr.preds[[i]],"tpr","fpr")
    lr.perfAUC[i] = unlist(performance(lr.preds[[i]], 'auc')@y.values)

  #random forest
    rfModel[[i]] = randomForest(train[,1] ~ ., data=train[,-1])
    rf.preds[[i]] = prediction(predict(rfModel[[i]], test[,-1]), test[,1])
    rf.perf[[i]] = performance(rf.preds[[i]],"tpr","fpr")
    rf.perfAUC[i] = unlist(performance(rf.preds[[i]], 'auc')@y.values)
  print(i)
  }
 ret=cbind(baseline.auc, brt.perfAUC, svm.perfAUC, lr.perfAUC, rf.perfAUC)
 colname(ret)=c('BASE', 'BRT', 'SVM', 'LR', 'RF')
return()
}



## get models for freshwater and marine parasites
freshOut=getModels(freshMatrix3, FT)
marineOut=getModels(marineMatrix3, MT)
```





```{r eval=TRUE, echo=TRUE, fig.cap='Mean predictive accuracy, measured as area under the ROC curve, for our null expectation (Base), boosted regression trees (BRT), support vector machines (SVM), logistic regression (LR), and random forest models (RF).'}

meanAUC=colMeans(freshOut)
meanSE = apply(freshOut,2,sd) / sqrt(nrow(freshOut))
meanSD = apply(freshOut,2,sd)
  
plot(1:5, meanAUC, ylim=c(0.45, 1), xlim=c(0.5,5.5), las=1, pch=16, tck=0.01, xaxt='n', xlab='Predictive model used', ylab='Area Under ROC curve')
abline(h=0.5, col=grey(0.5), lty=2, lwd=2)
segments(x0=1:5, y0=meanAUC+meanSD, y1=meanAUC-meanSD, col=grey(0.8),lwd=2)
points(1:5, meanAUC, pch=16, cex=1.5)
axis(1, at=1:5, labels=c('Base', 'BRT', 'SVM', 'LR', 'RF'), tck=0.01, srt=30)

```


```{r eval=TRUE, echo=TRUE}

meanAUC=colMeans(marineOut)
meanSE = apply(marineOut,2,sd) / sqrt(nrow(marineOut))
meanSD = apply(marineOut,2,sd)
  
  
plot(1:5, m.meanAUC, ylim=c(0.45, 1), xlim=c(0.5,5.5), las=1, pch=16, tck=0.01, xaxt='n', xlab='Predictive model used', ylab='Area Under ROC curve')
abline(h=0.5, col=grey(0.5), lty=2, lwd=2)
segments(x0=1:5, y0=m.meanAUC+m.meanSD, y1=m.meanAUC-m.meanSD, col=grey(0.8),lwd=2)
points(1:5, m.meanAUC, pch=16, cex=1.5)
axis(1, at=1:5, labels=c('Base', 'BRT', 'SVM', 'LR', 'RF'), tck=0.01, srt=30)

```





### Strona's FishPest database
```{r}
load('/media/drakelab/Lexar/8910Project/Analysis/pest.Rdata')
library(rfishbase); library(gbm); library(ROCR); library(e1071); library(randomForest)
## Creating a `fishMatrix` equiv.
#edgePest=edge2matrix(cbind(pest[,'H_SP'], pest[,'P_SP']))
#colnames(edgePest)=unique(pest[,'P_SP'])
#rownames(edgePest)=unique(pest[,'H_SP'])
#edgePest=edgePest[,-which(colSums(edgePest) < 50)]

# storage for model outputs
baseline.auc=vector(); 
brtModel=list(); brt.best.iter=list(); brt.preds=list(); brt.perf=list(); brt.perfAUC=vector()
svmModel=list(); svm.preds=list(); svm.perf=list(); svm.perfAUC=vector()
lrModel=list(); lr.preds=list(); lr.perf=list(); lr.perfAUC=vector()
rfModel=list(); rf.preds=list(); rf.perf=list(); rf.perfAUC=vector()


## Creating a pointsObject
#hostPest = unique(pest[,-c(1:3)], MARGIN=1)
hostPest = pest[,-c(1:3)]
parPest = names(summary(pest[,'P_SP'])>50); parPest=parPest[-100]


for(i in 1:length(parPest)){
#create presence vector
  presence=rep(0, nrow(hostPest))
  presence[which(hostPest[,'P_SP'] == parPest[i])]=1

#make some 'na' into actual NAs
  ugh=which(hostPest=='na', arr.ind=TRUE)
  hostPest[ugh]=NA
  hostPest[,7:17]=apply(hostPest[,7:17],2, as.numeric)

#Only train on some of the absences, since they're totally not true absences
  cutDown=c(which(presence==1), sample(which(presence==0), 5*sum(presence)))
  presence1=presence[cutDown]
  dat=hostPest[cutDown, -c(1,5)]

  # This makes sure that the test set contains at least 4 hosts on which the parasite actually occurs
  inds=sample(1:nrow(dat), 0.7*nrow(dat))
  if(sum(presence1[inds]) < 4){inds[1:4] = which(presence1 == 1)[1:4]}

#Impute the data
  impDat=rfImpute(dat[,-c(1:3)], presence1)
  dat=impDat[,-1]

#Set up a train set and a test set
  train = dat[inds,]
  test = dat[-inds,]
  
  #baseline expectations and null models
  baseline.auc[i] = performance(prediction(sample(presence[-inds], length(presence[-inds])), presence[-inds]), 'auc')@y.values
   
 ##trained models
 prezTR=presence1[inds]
 prezTE=presence1[-inds]

  #boosted regression trees
    brtModel[[i]] = gbm(prezTR ~ ., data=train, n.trees=50000, interaction.depth=4, distribution='bernoulli')
    brt.best.iter[[i]] = gbm.perf(brtModel[[i]], method="OOB")
    brt.preds[[i]] = prediction(predict(brtModel[[i]], newdata=test, n.trees=brt.best.iter[[i]]), prezTE)
    brt.perf[[i]] = performance(brt.preds[[i]],"tpr","fpr")
    brt.perfAUC[i]=unlist(performance(brt.preds[[i]], 'auc')@y.values)

  #support vector machines
    svmModel[[i]] = svm(prezTR ~ ., data=train, probability=TRUE)
    svm.preds[[i]] = prediction(predict(svmModel[[i]], test), prezTE)
    svm.perf[[i]] = performance(svm.preds[[i]],"tpr","fpr")
    svm.perfAUC[i] = unlist(performance(svm.preds[[i]], 'auc')@y.values)

  #logistic regression
    lrModel[[i]] = glm(prezTR ~ ., data=train, family=binomial)
    lr.preds[[i]] = prediction(predict(lrModel[[i]], test), prezTE)
    lr.perf[[i]] = performance(lr.preds[[i]],"tpr","fpr")
    lr.perfAUC[i] = unlist(performance(lr.preds[[i]], 'auc')@y.values)

  #random forest
    rfModel[[i]] = randomForest(prezTR ~ ., data=train)
    rf.preds[[i]] = prediction(predict(rfModel[[i]], test), prezTE)
    rf.perf[[i]] = performance(rf.preds[[i]],"tpr","fpr")
    rf.perfAUC[i] = unlist(performance(rf.preds[[i]], 'auc')@y.values)
  print(i)
  }


 ret=cbind(baseline.auc, brt.perfAUC, svm.perfAUC, lr.perfAUC, rf.perfAUC)
 colnames(ret)=c('BASE', 'BRT', 'SVM', 'LR', 'RF')
  
  






```


```{r}


getFishPest=function(pest, parVector){
  
  
  
  
  # storage for model outputs
  baseline.auc=vector(); 
  brtModel=list(); brt.best.iter=list(); brt.preds=list(); brt.perf=list(); brt.perfAUC=vector()
  svmModel=list(); svm.preds=list(); svm.perf=list(); svm.perfAUC=vector()
  lrModel=list(); lr.preds=list(); lr.perf=list(); lr.perfAUC=vector()
  rfModel=list(); rf.preds=list(); rf.perf=list(); rf.perfAUC=vector()

  for(i in 1:length(parVector)){

    occ = pest[which(pest[,'P_SP'] == parVector[i]),]
    occ = cbind(rep(1, nrow(occ)), occ[,-c(1:5)])
    colnames(occ)[1]='presence'
    
   #data imputation
    dat = rfImpute(dat[,-1], dat[,1])
    imputedData[[i]] = dat
  
  # This makes sure that the test set contains at least 4 hosts on which the parasite actually occurs
    pres=which(dat[,1]==1)
    inds=sample(1:nrow(dat), 0.7*nrow(dat))
    if(sum(pres %in% inds) < 4){inds[1:4]=pres[1:4]}
  
    train = dat[inds,]
    test = dat[-inds,]
  
  #baseline expectations and null models
    baseline.auc[i] = performance(prediction(test[sample(1:nrow(test), nrow(test)),1], test[,1]), 'auc')@y.values
   
 ##trained models
  #boosted regression trees
    weights=1/(sum(train[,1])/nrow(train))
    brtModel[[i]] = gbm(train[,1] ~ ., data=train[,-1], n.trees=60000, interaction.depth=4, distribution='bernoulli', weights=1+(train[,1] * weights))
    brt.best.iter[[i]] = gbm.perf(brtModel[[i]], method="OOB")
    brt.preds[[i]] = prediction(predict(brtModel[[i]], newdata=test[,-1], n.trees=brt.best.iter[[i]]), test[,1])
    brt.perf[[i]] = performance(brt.preds[[i]],"tpr","fpr")
    brt.perfAUC[i]=unlist(performance(brt.preds[[i]], 'auc')@y.values)

  #support vector machines
    svmModel[[i]] = svm(train[,1] ~ ., data=train[,-1], probability=TRUE)
    svm.preds[[i]] = prediction(predict(svmModel[[i]], test[,-1]), test[,1])
    svm.perf[[i]] = performance(svm.preds[[i]],"tpr","fpr")
    svm.perfAUC[i] = unlist(performance(svm.preds[[i]], 'auc')@y.values)

  #logistic regression
    lrModel[[i]] = glm(train[,1] ~ ., data=train[,-1], family=binomial)
    lr.preds[[i]] = prediction(predict(lrModel[[i]], test[,-1]), test[,1])
    lr.perf[[i]] = performance(lr.preds[[i]],"tpr","fpr")
    lr.perfAUC[i] = unlist(performance(lr.preds[[i]], 'auc')@y.values)

  #random forest
    rfModel[[i]] = randomForest(train[,1] ~ ., data=train[,-1])
    rf.preds[[i]] = prediction(predict(rfModel[[i]], test[,-1]), test[,1])
    rf.perf[[i]] = performance(rf.preds[[i]],"tpr","fpr")
    rf.perfAUC[i] = unlist(performance(rf.preds[[i]], 'auc')@y.values)
  print(i)
  }
 ret=cbind(baseline.auc, brt.perfAUC, svm.perfAUC, lr.perfAUC, rf.perfAUC)
 colname(ret)=c('BASE', 'BRT', 'SVM', 'LR', 'RF')
return()
}






```


```{r}
parVector=sort(table(pest$P_SP), decreasing=T)
parVector=names(parVector[which(parVector > 50)])



```

## Results









## Discussion


















```{r, message=FALSE, eval=FALSE, echo=FALSE}
#### DEPRECATED CODE #### 
# list of imputed data matrices
m.imputedData=list()

# storage for model outputs
m.baseline.auc=vector(); 
m.brtModel=list(); m.brt.best.iter=list(); m.brt.preds=list(); m.brt.perf=list(); m.brt.perfAUC=vector()
m.svmModel=list(); m.svm.preds=list(); m.svm.perf=list(); m.svm.perfAUC=vector()
m.lrModel=list(); m.lr.preds=list(); m.lr.perf=list(); m.lr.perfAUC=vector()
m.rfModel=list(); m.rf.preds=list(); m.rf.perf=list(); m.rf.perfAUC=vector()



for(i in 1:nrow(marineMatrix3)){
#data imputation
  dat = getPointsObject(marineMatrix3[i,], MT)
  dat = rfImpute(dat[,-1], dat[,1])
  m.imputedData[[i]] = dat
    
 #This makes sure that the test set contains at least 4 hosts on which the parasite actually occurs
  pres=which(dat[,1]==1)
  inds=sample(1:nrow(dat), 0.7*nrow(dat))
  if(sum(pres %in% inds) < 4){inds[1:4]=pres[1:4]}
  train = dat[inds,]
  test = dat[-inds,]
  
  #baseline expectations and null models
  m.baseline.auc[i] = performance(prediction(test[sample(1:nrow(test), nrow(test)),1], test[,1]), 'auc')@y.values
   
 ##trained models
  #boosted regression trees
  weights=1 / (sum(train[,1])/nrow(train))
  m.brtModel[[i]] = gbm(train[,1] ~ ., data=train[,-1], n.trees=50000, interaction.depth=4, distribution='bernoulli', weights=1+(train[,1] * weights))
  m.brt.best.iter[[i]] = gbm.perf(m.brtModel[[i]], method="OOB")
  m.brt.preds[[i]] = prediction(predict(m.brtModel[[i]], newdata=test[,-1], n.trees=m.brt.best.iter[[i]]), test[,1])
  m.brt.perf[[i]] = performance(m.brt.preds[[i]],"tpr","fpr")
  m.brt.perfAUC[i]=unlist(performance(m.brt.preds[[i]], 'auc')@y.values)

  #support vector machines
  m.svmModel[[i]] = svm(train[,1] ~ ., data=train[,-1])
  m.svm.preds[[i]] = prediction(predict(m.svmModel[[i]], test[,-1]), test[,1])
  m.svm.perf[[i]] = performance(m.svm.preds[[i]],"tpr","fpr")
  m.svm.perfAUC[i] = unlist(performance(m.svm.preds[[i]], 'auc')@y.values)

  #logistic regression
  m.lrModel[[i]] = glm(train[,1] ~ ., data=train[,-1], family=binomial)
  m.lr.preds[[i]] = prediction(predict(m.lrModel[[i]], test[,-1]), test[,1])
  m.lr.perf[[i]] = performance(m.lr.preds[[i]],"tpr","fpr")
  m.lr.perfAUC[i] = unlist(performance(m.lr.preds[[i]], 'auc')@y.values)

  #random forest
  m.rfModel[[i]] = randomForest(train[,1] ~ ., data=train[,-1])
  m.rf.preds[[i]] = prediction(predict(m.rfModel[[i]], test[,-1]), test[,1])
  m.rf.perf[[i]] = performance(m.rf.preds[[i]],"tpr","fpr")
  m.rf.perfAUC[i] = unlist(performance(m.rf.preds[[i]], 'auc')@y.values)
  
  print(i)
}



```

